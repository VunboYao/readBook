# Jsonp实现

```js
function myJsonp(options = {}) {
  let url = options.url;
  // 1.1 check Jsonp Key
  if (options.jsonp) {
    url += '?' + options.jsonp + '='
  } else {
    url += '?callback=';
  }

  // 1.2 Jsonp Name
  let callBackName = ('jQuery' + Math.random()).replace('.', '');
  if (options.jsonpCallback) {
    callBackName = options.jsonpCallback;
    url += options.jsonpCallback;
  } else {
    url += callBackName;
  }

  // 1.3 Jsonp Data
  if (options.data) {
    let str = obj2str(options.data);
    url += '&' + str;
  }

  // 2.Get Cross Data
  let oScript = document.createElement('script');
  oScript.src = url;
  document.body.appendChild(oScript);

  // 3.Define callBack()
  window[callBackName] = function (data) {
    // return data
    options.success(data);
    // removeScriptTag
    document.body.removeChild(oScript);
  }
}

function obj2str(obj) {
  // random str => cache
  obj.t = (Math.random() + '').replace('.', '');
  let arr = [];
  for (let key in obj) {
    arr.push(key + '=' + encodeURIComponent(obj[key]));
  }
  let str = arr.join('&');
  return str;
}
````

# 程序

程序是指将 **编译型语言** 编写好的代码通过编译工具编译之后 **存储在硬盘** 上的一个 **二进制文件**，会占用磁盘空间，但不会占用系统资源

# 进程

进程是指 **程序** 在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位

# 线程

**线程** 是指 **进程** 中的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位

- 一个进程至少有一个线程，这个线程称为 **主线程**
- 除了主线程，还可以创建和销毁多个线程

# 串行

同一个时刻，只有一条指令，在一个CPU上执行，后面的指令必须等到前面指令执行完才能执行

# 并行

同一个时刻，多条指令，多个CPU上执行

# 事件循环

JS 中除了“事件绑定的函数” 和 “回调函数” 以外的都是同步代码

- 程序运行会从上到下依次执行所有的同步代码
- 执行过程中遇到异步代码会将异步代码放到事件循环中
- 当所有同步代码都执行完毕，JS 会不断检测事件循环中的异步代码是否满足条件
- 一旦满足条件就会执行满足条件的异步代码

# 数组合并

```js
let a = [
    {id: 'a', count: 2},
    {id: 'b', count: 3}
]
let b = [
    {id: 'a', count: 1},
    {id: 'b', count: 2},
    {id: 'c', count: 4}
]

function concat(arr1, arr2) {
    let arr = [...arr1, ...arr2];
    let ids = {}
    /* 数组遍历 */
    return arr.filter((item, index) => {
        /* 如果当前 id 在 ids 中 */
        if (item.id in ids) {
            /* 若当前 id 已存在，则在数组中查询对应 id 的索引，+= 当前 id 的 count */
            arr[ids[item.id]].count += item.count;
            return false;
        } else {
            /* 当前id 不在 ids 中，设置 ids = {id：index} */
            ids[item.id] = index;
            /* filter 返回为 true 的数组元素 */
            return true;
        }
    })
}
```

# 数组位置转换

`[1 ,2, 3, 4] ===> [1, 2, 4, 3]`

```js
function arrIndexExchange(array,x,y) {
  /*
  * 解析：
  * x-1,1, 删除索引 X 的值
  * y-1,1,array[x-1]， 删除索引 Y 的值，插入X的值
  * ...array, 扩展加入到 X 的位置
  * */
  let a = array.splice(x-1, 1, ...array.splice(y-1, 1, array[x-1]));
  return array;
}

let arr = [1,2,3,4];
console.log(arrIndexExchange(arr,3,4));
```

# 时间格式转 02:12

```js
const convertDuration = time => {
  let minutes = Math.floor(time / 60);
  let seconds = Math.floor(time - minutes * 60);
  minutes = String(minutes).length < 2 ? String(minutes).padStart(2,'0'): minutes;
  seconds = String(seconds).length < 2 ? String(seconds).padStart(2,'0'): seconds;
  return minutes + ":" + seconds;
};

convertDuration(308); // 05:08
convertDuration(6000); // 100:00
```

# 时间格式转 01:12:05

```js
const convertDuration = time => {
  let hours = Math.floor(time / 60 / 60); // 取小时
  let minutes = (Math.floor(time / 60) - hours * 60); // 总分钟数-小时*60
  let seconds = time % 60; // 秒数取余
  hours = String(hours).length < 2 ? String(hours).padStart(2, '0') : hours;
  minutes = String(minutes).length < 2 ? String(minutes).padStart(2, '0') : minutes;
  seconds = String(seconds).length < 2 ? String(seconds).padStart(2, '0') : seconds;
  return hours + ":" + minutes + ":" + seconds;
};

console.log(convertDuration(36000)); // 10:00:00
```

# 闭包

- A函数作用域内部有一个B函数, B函数调用A函数内的变量, 当B函数被当作一个值类型传递时, 在A函数外部通过不同的标识执行B函数时,产生闭包

  ```javascript
  function A() {
      let a = 1
      function B() {
          console.log(a) // 1
      }
      return B
  }
  const c = A()
  c()
  ```

- 对函数类型的值进行传递, 当函数在别处被调用时都可以观察到闭包

  ```javascript
  function A() {
      let a = 2
  
      function B() {
          console.log(a) // 2
      }
  
      C(B)
  }
  function C(fn) {
      fn()
  }
  A()
  ```

- 间接的将内部函数传递到所在的词法作用域以外, 都会持有对原始定义作用域的引用, 无论在何处执行这个函数都会使用闭包

- 定时器中函数的引用

  ```javascript
  function await(msg) {
  	setTimeout(function timer() {
  		console.log(msg)
  	}, 1000)
  }
  await('hello closure')
  ```

- 如果将访问各自词法作用域的函数当作第一级的值类型并到处传递, 就是闭包的使用...定时器、事件监听器、Ajax请求等。

- **将A函数内部的B函数当作一个值引用或传递，当B函数引用了A函数内部的变量时，则会产生闭包**

- **循环与闭包**

  ```javascript
  for (var i = 0; i <= 5; i++){
      (function (j) {
          setTimeout(() => {
              console.log(j)
          }, 500)
      })(i)
  }
  // 循环迭代内使用IIFE（Immediately Invoked Function Expression）会为每一个迭代都生成一个新的作用域， 使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值得变量供访问
  ```

# ReferenceError 与 TypeError 错误类型

- 引用错误, 作用域中找不到该变量
- 类型错误, 作用域中查到该变量, 但执行方式错误.

# this指向

- 默认绑定，谁调用`this`指向谁
- 隐式绑定, 在一个对象内部包含一个指向函数的属性, 并通过这个属性间接引用函数, 从而把 `this` 间接(隐式)绑定到这个对象上
- 显式绑定, **call(...)和apply() 方法**. 第一个参数是一个对象, 是给this准备的, 在调用时将其绑定到this.**如果传入了一个原始值来当作this的绑定对象, 这个原始值会被转换成它的对象形式. 这通常被称为'装箱'**. `bind(..)`会返回一个硬编码的新函数
- new绑定

##　判断this

- **函数是否在 new 中调用(new绑定)? 如果是的话 this 绑定的是新创建的对象**
  - `var bar = new foo()`

- **函数是否通过 call, apply (显示绑定) 或者硬绑定调用 ? 如果是的话, this 绑定的是指定的对象**
  - `var bar = foo.call(obj2)`

- **函数是否在某个上下文对象中调用(隐士绑定) ?　如果是的话，this 绑定的是那个上下文对象**
  - `var bar = obj1.foo()`

- **如果都不是的话, 使用默认绑定. 如果在严格模式下, 就绑定到 undefined, 否则绑定到全局对象中**
  - `var bar = foo()`

## 被忽略的this

- **如果把null或者undefined作为this的绑定对象传入call, apply或bind, 这些值在调用时会被忽略, 实际应用的是默认绑定规则**

- **null作为占位置**

## 更安全的this

**Object.create(null) **

# 函数类型

- 函数对象
- 实例对象
- 原型对象
