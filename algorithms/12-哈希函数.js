/*
哈希化：将大数字转化成数组范围内下标的过程，称之为哈希化
哈希函数：通常我们会将单词转换成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数称为哈希函数
哈希表：将数据存储到数组中，对整个结构的封装，称之为是一个哈希表

1. 单词/字符串转换成数组下标值。 字符编码，ASCII, GBK, Unicode
2. 单词 => 数字
    1.数字相加：可能很多单词转换后的数字之和重复
    2.幂的连乘：cats = 3 * 27^3 + 1*27^3 + 20&27 + 17 = 60337.基本保证唯一性.
       a.如果某一个单词转换的数字太大，数组无法设置这么大的下标值，内存不足。
       b.间隔太大，空间浪费

哈希化：将幂的连乘方案中的巨大的整数范围压缩到可以接受的数组范围中
1. 取余操作：index = largeNumber % smallNumber（概率产生一样的下标）
2. 解决冲突：链地址法 和 开放地址法

  链地址法（拉链法）：将数组的每一个位置存储为一个数组/链表

  开放地址法：寻找空白的单元格来添加重复的数据
    - 线性探测：
        添加：线性查找空白单元
        查询：如果没有数据，查到空位置就停止
        删除：不可以将该位置的下标置为null,置为-1，继续查询
        问题：聚集：一连串填充单元，影响性能
    - 二次探测：一次探测比较长的距离，1，4，9，16
    - 再哈希法

填充因子 = 已经包含的数据项 / 哈希表长度
开放地址法：装填因子最大是 1， 寻找空白单元将元素放入
链地址法： 可以大于 1， 因为拉链法可以无限的延伸下去。

*/

/*
设计哈希函数：
1.将字符串转成比较大的数字：hashCode
2.将大的数字hashCode压缩到数组范围（大小）之内
*/

function hashFunc(str, size) {
  // 1.定义hashCode变量
  let hashCode = 0

  // 2.霍纳算法，计算hashCode的值
  for (let i = 0; i < str.length; i++) {
    hashCode = 37 * hashCode + str.charCodeAt(i)
  }
  // 3.取余操作
  index = hashCode % size

  return index
}

console.log(hashFunc('cat', 6));
console.log(hashFunc('cat2', 6));
console.log(hashFunc('cat1', 6));
