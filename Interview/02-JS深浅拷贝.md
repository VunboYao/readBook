# 浅拷贝的原理和实现

> 自己创建一个新的对象，来接受你要重新复制或引用的对象值。
>
> - 如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象
> - 如果属性是引用数据类型，复制的就是**内存中的地址**，如果其中一个对象改变了这个内存的地址，肯定会影响到另一个对象

## `object.assign`

该方法用于浅拷贝。第一个参数是拷贝的目标对象，后面的参数是拷贝的来源对象（也可以是多个来源，相同属性取最后一个来源的值）

> `object.assign` 的语法为：`Object.assign(target, ...sources)`

```js
let target = {}
let source = { a: { b: 1 }}
Object.assign(target, source)
console.log(target) // { a: { b: 1 } }
```

```javascript
let target = {}
let source = { a: { b: 1 }}
Object.assign(target, source)
console.log(target) // { a: { b: 1 } }
source.a.b = 10
console.log(source) // { a: { b: 10 } }
console.log(target) // { a: { b: 10 } }
```

使用 `object.assign` 方法注意点：

- 不会拷贝对象的继承属性
- 不会拷贝对象的不可枚举属性
- 可以拷贝 Symbol 类型的属性

```js
let obj1 = {
    a: {
        b: 1
    },
    sym: Symbol(1)
}
Object.defineProperty(obj1, 'innumerable', {
    value: '不可枚举属性',
    enumerable: false
})
let obj2 = {}
Object.assign(obj2, obj1)
obj1.a.b = 2
console.log(obj1) // { a: { b: 2 }, sym: Symbol(1) }, [innumerable: '不可枚举属性']
console.log(obj2) // { a: { b: 2 }, sym: Symbol(1) }

// 可以简单的理解为：Object.assign 循环遍历原对象的属性，通过复制的方式将其复制给目标对象的相应属性。
```

## 扩展运算符方式

扩展运算方式：`let cloneObj = {...obj}`

```js
let obj1 = {
    a: 1,
    b: {
        c: 1
    }
}
let obj2 = {...obj1}
obj2.a = 2
obj1.b.c = 2
console.log(obj1) // { a: 1, b: { c: 2 } }
console.log(obj2) // { a: 2, b: { c: 2 } }

// 数组的拷贝
let arr = [1,2,3]
let newArr = [...arr]
```

## `concat` 拷贝数组

```js
let arr = [1,2,3]
let newArr = arr.concat()
newArr[1] = 100
console.log(arr) // [ 1, 2, 3 ]
console.log(newArr) // [ 1, 100, 3 ]
```

## `slice` 拷贝数组

```js
let arr = [1,2,{val:  4}]
let newArr = arr.slice()
newArr[2].val = 100
console.log(arr) // [ 1, 2, { val: 100 } ]
```

## 手工实现一个浅拷贝

