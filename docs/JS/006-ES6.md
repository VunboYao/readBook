# 变量

- var
  - 可以重复声明
  - 无法限制修改
  - 没有块级作用域
- let: 不能重复声明, 变量可以修改,块级作用域
- const: 不能重复声明,常量不能修改,块级作用域

# 箭头函数

- 只有一个参数时括号可以省略
- 只有一个 return 时, 大括号可以省略

# 函数

- 参数扩展/数组展开 ...
- 默认参数

# 解构赋值

- **本质是找到同名的属性,再赋值给对应的变量, 真正被赋值的是后者, 而不是前者**
- 左右两边结构必须一样
- 右边必须是合法的语句
- 声明和复制不能分开(必须一句话里完成)

# 数组

- map 映射-------------一个对一个
- reduce 汇总----------一堆算出来一个
  - 参数: prev, cur, index, arr
- filter --------------过滤器
- forEach--------------迭代
- includes-------------包含
- keys/values/entries

## for/in 与 for/of

| 方式   | 数组     | json  |
| ------ | -------- | ----- |
| for/in | 下标 key | key   |
| for/of | 值 value | error |

- for/in 专用于对象/无序对象
- for/of 专用于数组
- keys/values/entries 实体
- for (let index of arr.keys()){}

```javascript
let arr = [123, 4, 23, 11]
for (let i of arr.entries()) {
  console.log(i)
}
```

- 扩展运算符(spread)

- 替代函数的 apply 方法

  ```javascript
  // ES5 的写法
  Math.max.apply(null, [14, 3, 77])

  // ES6 的写法
  Math.max(...[14, 3, 77])

  // 等同于
  Math.max(14, 3, 77)
  ```

- 数组的拼接. `arr1.push(...arr2)`

- 克隆数组

  ```javascript
  const a1 = [1, 2]
  // 写法一
  const a2 = [...a1]
  // 写法二
  const [...a2] = a1
  ```

- **合并数组 `[...arr1, ...arr2]`, 与`arr1.concat(arr2)`一样**, 两种方法都是浅拷贝

- 与解构赋值结合使用时, 必须放到参数的最后一位, 否则会报错

- 扩展运算符可以将字符串转为真正的数组, 并且能够识别四个字节的 Unicode 字符

  ```javascript
  function length(str) {
    return [...str].length
  }

  length('x\uD83D\uDE80y') // 3
  ```

- 实现了 遍历器(iterator) 接口的对象, 都可以用扩展运算符转为真正的数组

- **`Array.from`方法用于将两类对象转为真正的数组**：类似数组的对象（array-like object）和可遍历（iterable）的对象

  - 只要是部署了 Iterator 接口的数据结构，`Array.from`都能将其转为数组。
  - 任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。

  - **`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法**，用来对每个元素进行处理，将处理后的值放入返回的数组。

    ```javascript
    Array.from(arrayLike, x => x * x)
    // 等同于
    Array.from(arrayLike).map(x => x * x)

    Array.from([1, 2, 3], x => x * x)
    // [1, 4, 9]
    ```

  - `Array.from`的第三个参数，用来绑定`this`

- **Array.of 方法用于将一组值，转换为数组**。空则返回空数组

  ```javascript
  Array.of(3, 11, 8) // [3,11,8]
  Array.of(3) // [3]
  Array.of(3).length // 1
  ```

  - `Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

  - `Array.of`方法可以用下面的代码模拟实现。

    ```javascript
    function ArrayOf() {
      return [].slice.call(arguments)
    }
    ```

- 数组实例的 copyWithin()

  数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

  ```javascript
  Array.prototype.copyWithin(target, (start = 0), (end = this.length))
  ```

  接受三个参数

  - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
  - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
  - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

  ```javascript
  ;[1, 2, 3, 4, 5].copyWithin(0, 3)
  // [4, 5, 3, 4, 5]
  // 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。
  ```

- **find() 和 findIndex()**

  - 数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。
  - **`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组**。

  - 数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。

  - 这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。

  - **这两个方法都可以发现`NaN`，弥补了数组的`indexOf`方法的不足**

    ```javascript
    ;[NaN]
      .indexOf(NaN)
      // -1

      [NaN].findIndex(y => Object.is(NaN, y))
    // 0
    ```

- **数组实例的 fill()**

  - `fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

    ```javascript
    ;['a', 'b', 'c'].fill(7)
    // [7, 7, 7]

    new Array(3).fill(7)
    // [7, 7, 7]
    ```

  - **`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置**。

    ```javascript
    ;['a', 'b', 'c'].fill(7, 1, 2)
    // ['a', 7, 'c']
    ```

  - 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。

- 数组实例的 **entries(), keys() 和 values() 方法**, 可以用 for...of 循环进行遍历

- 数组实例的 includes(), 返回一个布尔值, 第二个参数表示起始位置默认为 0, 如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为`-4`，但数组长度为`3`），则会重置为从`0`开始。

  ```javascript
  ;[1, 2, 3].includes(3, 3) // false
  ;[1, 2, 3].includes(3, -1) // true
  ```

- 数组的成员有时还是数组，`Array.prototype.flat()`用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响

  ```javascript
  ;[1, 2, [3, 4]].flat()
  // [1, 2, 3, 4]
  ```

- `flat()`默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将`flat()`方法的参数写成一个整数，表示想要拉平的层数，默认为 1。

  ```javascript
  ;[1, 2, [3, [4, 5]]].flat()[
    // [1, 2, 3, [4, 5]]

    (1, 2, [3, [4, 5]])
  ].flat(2)
  // [1, 2, 3, 4, 5]
  ```

- 如果不管有多少层嵌套，都要转成一维数组，可以用`Infinity`关键字作为参数。
- 如果原数组有空位，`flat()`方法会跳过空位。

- `flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。

  ```javascript
  // 相当于 [[2, 4], [3, 6], [4, 8]].flat()
  ;[2, 3, 4].flatMap(x => [x, x * 2])
  // [2, 4, 3, 6, 4, 8]
  ```

- `flatMap()`只能展开一层数组。

- `flatMap()`方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。`flatMap()`方法还可以有第二个参数，用来绑定遍历函数里面的`this`。

- ES6 明确将空位转为`undefined`。

# 字符串

- startsWith('http')----------以 http 开头
- endsWith('.txt')------------以 txt 结尾的
- padStart(minLen, str), 第一个参数为指定参数的最小长度,第二个参数用来补全字符串. 如果省略第二个参数, 则用空格来补全
- padEnd(minLen, str)
- 模板字符串

# 面向对象

## class 关键字,定义类

- class 中有个 constructor 方法, 这就是构造方法, **this 关键字** 则代表实例对象.
- class 中定义方法时, **不需要** 添加 **function** 关键字, 方法之间**不需要逗号分隔**
  ```javascript
  class Point {
    constructor(x, y) {
      this.x = x
      this.y = y
    }
    toString() {
      return `(${this.x}, ${this.y})`
    }
  }
  let p = new Point(1, 2)
  console.log(typeof Point) // function
  console.log(Point === Point.prototype.constructor) // true
  ```
- **类的数据类型就是函数, 类本身就指向构造函数**
- 构造函数的 prototype 属性, 在 ES6 的 '类'上面继续存在. 事实上, 类的所有方法都定义在类的 prototype 属性上面
- 由于类的新方法可以添加在 prototype 对象上面. Object.assign 方法可以很方便的一次向类添加多个方法
  ```javascript
  class Point {
    constructor(x, y) {}
  }
  Object.assign(Point.prototype, {
    toString() {},
    toValue() {},
  })
  ```
- **类的内部所有定义的方法, 都是不可枚举的(non-enumerable)**, 无法通过 Object.keys(Point.prototype) 获取方法. **ES5 中方法可以枚举.**

## constructor

- constructor 方法是类的**默认方法**, 通过 new 命令生成对象时, 自动调用该方法. **必须有 constructor 方法**, 若没有显示定义, 一个空的 constructor 方法会被默认添加
- constructor 方法**默认返回实例对象 (即 this)**, 可以指定返回**另外一个对象**. 则 instanceof 方法会返回 false
- **必须通过 new 调用**,否则会报错.

## 类的实例

- 与 ES5 一样, 实例的属性除非显示定义在其本身 (即定义在 **this** 对象上), 否则都是定义在原型上 (即定义在 **class** 上)
- hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例
  的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty("name") ）。
- 与 ES5 一样, 类的所有实例共享一个原型对象. 可以通过 **\_\_proto\_\_** 为"类"添加方法,但最好不要.

## 取值函数 (getter) 和存值函数 (setter)

- 与 ES5 一样, 在'类'的内部可以使用 get 和 set 关键字, 对某个属性设置存值函数和取值函数,拦截该属性的存取行为.
  ```javascript
  class Myclass {
    constructor() {}
    get prop() {
      return 'getter'
    }
    set prop(value) {
      console.log('setter: ' + value)
    }
  }
  let demo = new Myclass()
  demo.prop = 123 // setter: 123
  console.log(demo.prop) // getter
  ```
- 存值函数和取值函数是设置在属性的 Descriptor 对象上的. 与 ES5 完全一致

## 属性表达式

- 类的属性名,可以采用表达式
  ```javascript
  let methodName = 'getA'
  class Square {
    constructor(le) {}
    [methodName]() {}
  }
  ```

## Class 表达式

- 与函数一样, 类也可以使用表达式的形式定义
- 采用 class 表达式, 可以写出立即执行的 class
  ```javascript
  let person = new (class {
    constructor(name) {
      this.name = name
    }
    sayName() {
      console.log(this.name)
    }
  })('yyb')
  person.sayName() // yyb
  ```

## 注意点:

- 默认严格模式
- 类**不存在变量提升** (hoist), 与 ES5 完全不同
- name 属性总是返回紧跟在 class 关键字后面的类名.
- 如果方法之前加上星号(\*),表示该方法是一个 Generator 函数.
- this 的指向,默认指向类的实例.

## 静态方法

- 类相当于实例的原型, 所有在类中定义的方法, 都会被实例继承. 如果在一个方法之前, 加上 static 关键字, 就表示该方法不会被实例继承, 而是直接通过类来调用. 这就称为 **"静态方法"**

  ```javascript
  class Foo {
    static classMethod() {
      console.log('hello')
    }
  }
  Foo.classMethod() // hello

  let foo = new Foo()
  foo.classMethod() // TypeError: foo.classMethod is not a function
  ```

- **如果静态方法包含 this 关键字, 这个 this 指的是类,而不是实例**
- 静态方法可以与非静态方法重名, 父类的静态方法, 可以被子类继承. 静态方法也可以从 super 对象上调用

## 实例属性的新写法

- 实例属性除了定义在 constructor() 方法里面的 this 上面, 也可以定义在类的最顶层
- 实例属性与方法在同一层级, 不需要在实例属性前面加上 this

## 静态属性

- 静态属性指的是 Class 本身的属性, 即 **Class.propName**, 而不是定义在实例对象 (this) 上的属性.

  ```javascript
  class Foo {}

  Foo.prop = 1
  console.log(Foo.prop) // 1
  ```

- 目前,只有这种写法可行, 因为 ES6 明确规定, Class 内部只有静态方法, 没有静态属性.
- 有一个提案: 在实例属性的前面,加上 static 关键字.
  ```javascript
  class Foo {
    static prop = 1
    constructor() {
      console.log(Foo.prop)
    }
  }
  ```

## 私有方法和私有属性

- 私有方法和私有属性, 是只能在类的内部访问的方法和属性, 外部不能访问. 这是常见需求,有利于代码的封装, 但 ES6 不提供, 只能通过变通方法实现.
- 一种是在命名上加以区别. 如 \_bar. 方法前加上下划线,表示一个只限内部使用的方法. 但是不保险, 在类的外部, 还是可以调用到这个方法.
- 另一种方法索性将私有方法移出模块, 因为模块内部的所有方法都是对外可见的.
- 还有一种方法是利用 **Symbol** 值的唯一性, 将私有方法的名字命名为一个 Symbol 值. 但是也不是绝对不行, Reflect.ownKeys() 依然可以拿到它们.

## 私有属性的提案

- 在属性名前加上'#'表示私有属性.
- 只能在内部使用,在类的外部使用则报错.
- 也可以用于私有方法
- 私有属性也可以设置 getter 和 setter 方法
- 私有属性不限于从 this 引用, 只要是在类的内部, 实例也可以引用私有属性.
- 私有属性和私有方法前面, 也可以加上 static 关键字, 表示这是一个静态的私有属性或私有方法.

## new.target 属性

new 是从构造函数生成实例对象的命令. ES6 为 new 命令引入了一个 new.target 属性, 该属性一般用在构造函数之中, **返回 new 命令作用的那个构造函数**. 如果构造函数不是通过 new 命令或 Reflect.construct() 调用的. new.target 会返回 undefined, 因此这个属性可以用来确定构造函数是怎么调用的.

```javascript
function Person(name) {
  if (new.target !== undefined) {
    this.name = name
  } else {
    throw new Error('please use new command')
  }
}
// 另一种写法
function Person(name) {
  if (new.target === Person) {
    this.name = name
  } else {
    throw new Error('please use new command')
  }
}
let person = new Person('yb') // 正确
let notAPerson = Person.call(person, 'yb') // error
```

```javascript
// Class 内部调用 new.target, 返回当前 Class
class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle)
    this.length = length
    this.width = width
  }
}
let obj = new Rectangle(3, 4) // true
```

- 需要注意的是, 子类继承父类时, new.target 会返回子类.

```javascript
class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle)
  }
}
class Square extends Rectangle {
  constructor(length, width) {
    super(length, width)
  }
}

let obj = new Square(3, 4) // false
console.log(obj) // Square
```

- 利用这个特点,可以写出不能独立使用,必须继承后才能使用的类

```javascript
class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('本类不能实例化')
    }
  }
}
class Rectangle extends Shape {
  constructor(length, width) {
    super()
  }
}

var x = new Shape() // 报错
var y = new Rectangle(3, 4) // 正确
```

- 上面的代码, Shape 类不能被实例化, 只能用于继承. 注意, 在函数外部, 使用 new.target 会报错.

# Class 继承

- Class 可以通过 **extends** 关键字实现继承.
- **super** 表示父类的构造函数, 用来创建父类的 **this** 对象
- **子类必须在 constructor 方法中调用 super 方法**, 否则新建实例时会报错. 这是因为子类自己的 this 对象, 必须先通过父类的构造函数完成塑造, 得到与父类同样的实例属性和方法, 然后再对其进行加工, 加上子类自己的实例属性和方法. 如果不调用 super 方法, 子类就得不到 this 对象.
- 如果子类没有定义 constructor 方法, 这个方法会被默认添加.

  ```javascript
  class ColorPoint extends Point {}

  // 等同于
  class ColorPoint extends Point {
    constructor(...args) {
      super(...args)
    }
  }
  ```

- **注意点: 在子类的构造函数中, 只有调用 super 之后, 才可以使用 this 关键字.**
- 父类的静态方法, 也会被子类继承.

## Object.getPrototypeOf()

- Object.getPrototypeOf 方法可以用来从子类上获取父类.
- 因此,可以使用这个方法判断,一个类是否继承了另一个类

```javascript
console.log(Object.getPrototypeOf(ColorPoint) === Point) // true
```

## super 关键字

- super 关键字, 可以当作函数使用, 也可以当作对象使用. 在这两种情况下, 它的用法完全不同.
- **作为函数调用时:** super 代表调用父类的构造函数. 这是必须的, 否则 error.

  ```javascript
  class A {}

  class B extends A {
    constructor() {
      super()
    }
  }
  ```

- **注意:** super 虽然代表了父类 A 的构造函数, 但是返回子类 B 的实例, 即 super 内部的 this 指的是 B 的实例.因此 super() 在这里相当于
  ```javascript
  A.prototype.constructor.call(this)
  ```
- super() 作为函数时, 只能用在子类的构造函数中, 用在其他地方就会报错.
- **super 作为对象时: 在普通方法中, 指向父类的原型对象; 在静态方法中, 指向父类**
  ```javascript
  class A {
    p() {
      return 2
    }
  }
  class B extends A {
    constructor() {
      super()
      console.log(super.p()) // 2
    }
  }
  let b = new B()
  /* 上面代码中,子类 B 当中的 super.p(), 就是将 super 当作一个对象使用.
    这时, super 在普通方法之中, 指向 A.prototype, 所以 super.p() 就相当于
    A.prototype.p()
  */
  ```
- 注意: super 指向父类的原型对象, 所以定义在父类实例上的方法或属性, 是无法通过 super 调用的.

  ```javascript
  class A {
    constructor() {
      this.p = 2
    }
  }
  class B extends A {
    get m() {
      return this.p
    }
  }
  let b = new B()
  console.log(b.m) // undefined
  // p 是父类 A 的实例属性, super.p 就引用不到它.

  // 如果属性定义在父类的原型对象上, super就可以取到
  class A {
    constructor() {
      this.p = 2
    }
  }
  A.prototype.x = 2
  class B extends A {
    get m() {
      return super.x
    }
  }
  let b = new B()
  console.log(b.x) // 2
  ```

- 在子类普通方法之中通过 super 调用父类的方法时, 方法内部的 this 指向当前的子类实例

  ```javascript
  class A {
    constructor() {
      this.x = 1
    }
    print() {
      console.log(this.x)
    }
  }

  class B extends A {
    constructor() {
      super()
      this.x = 2
    }
    m() {
      super.print()
    }
  }

  let b = new B()
  b.m() // 2
  ```

- 由于 this 指向子类实例, 所以如果通过 super 对某个属性赋值, 这时 super 就是 this, 赋值的属性会变成子类实例的属性

  ```javascript
  class A {
    constructor() {
      this.x = 1
    }
  }

  class B extends A {
    constructor() {
      super()
      this.x = 2
      super.x = 3
      console.log(super.x) // undefined
      console.log(this.x) // 3
    }
    m() {
      super.print()
    }
  }

  let b = new B()
  /*super.x 赋值为 3, 这时等同于对 this.x 赋值为 3. 而当读取 super.x 的时候,
    读取的是 A.prototype.x, 所以返回 undefined
  */
  ```

- **如果 super 作为对象, 用在静态方法之中, 这时 super 将指向父类, 而不是父类的原型对象**

  ```javascript
  class Parent {
    static myMethod(msg) {
      console.log('static', msg)
    }
    myMethod(msg) {
      console.log('instance', msg)
    }
  }
  class Child extends Parent {
    static myMethod(msg) {
      super.myMethod(msg) // 指向 Parent, 而不是 Parent.prototype
    }
    myMethod(msg) {
      super.myMethod(msg)
    }
  }
  Child.myMethod(1) // static 1

  let child = new Child()
  child.myMethod(2) // instance 2
  // super 在静态方法之中指向父类, 在普通方法之中指向父类的原型对象
  ```

- 在子类的静态方法中通过 super 调用父类的方法时, 方法内部的 this 指向当前的子类, 而不是子类的实例.
- 注意: 使用 super 的时候, 必须显示指定是作为函数, 还是作为对象使用, 否则会报错.
- 对象总是继承其他对象的, 所以可以在任意一个对象中, 使用 super 关键字.

  ```javascript
  var obj = {
    toString() {
      return 'MyObject: ' + super.toString()
    },
  }

  obj.toString() // MyObject: [object Object]
  ```

## 类的 prototype 属性和 \_\_proto\_\_ 属性

- 子类的 \_\_proto\_\_ 属性, 表示构造函数的继承, 总是指向父类
- 子类 prototype 属性的 \_\_proto\_\_ 属性, 表示方法的继承, 总是指向父类的 prototype 属性.

  ```javascript
  class A {}
  class B extends A {}

  console.log(B.__proto__ === A) // true
  console.log(B.prototype.__proto__ === A.prototype) // true
  ```

  > 上面代码中, 子类 B 的 \_\_proto\_\_ 属性指向父类 A, 子类 B 的 prototype 属性的 \_\_proto\_\_ 属性指向父类 A 的 prototype 属性.这样的结果是因为, 类的继承是按照下面的模式实现的.

```javascript
class A {}
class B {}

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype)
// B 继承 A 的静态属性
Object.setPrototypeOf(B, A)

const b = new B()
```

- 对象扩展中给出 Object.setPrototypeOf 方法的实现

```javascript
Object.setPrototypeOf = function(obj, proto) {
  obj.__proto__ = proto
  return obj
}
// 因此得到了上面的结果

Object.setPrototypeOf(B.prototype, A.prototype)
// 等同于
B.prototype.__proto__ = A.prototype

Object.setPrototypeOf(B, A)
// 等同于
B.__proto__ = A
```

> 这两条继承链, 可以这样理解: 作为一个对象, 子类 (B) 的原型 (\_\_proto\_\_ 属性)是父类 (A); 作为一个构造函数, 子类 (B) 的原型对象 (prototype 属性) 是父类的原型对象 (prototype 属性) 的实例.

## 原生构造函数的继承

- 原生构造函数是指语言内置的构造函数, 通常用来生成数据结构.
  - Boolean()
  - Number()
  - String()
  - Array()
  - Date()
  - Function()
  - RegExp()
  - Error()
  - Object()
- ES5 不能继承以上原生构造函数, 因为子类无法获取原生构造函数的内部属性. ES5 是先新建子类的实例对象 this, 再将父类的属性添加到子类上, 由于父类的内部属性无法获取, 导致无法继承原生的构造函数.
- ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。

# JSON

- JSON 对象
  - JSON.stringify
  - JSON.parse
- 简写
  - 名字跟值( key 和 value )一样的,写一个就行
  - 方法: show: function(){...}, 写为 show(){}

# Promise

- Promise 对象代表一个异步操作, 有三种状态: **pending (进行中)**, **fulfilled (完成)** 和 **rejected (失败)**. 只有异步操作的结果, 可以决定当前是哪一种状态.
- 一旦状态改变, 就不会再变, 任何时候都可以得到这个结果.
- 创建 Promise, `new Promise((resolve,reject) => {})`

## 基本用法

- ES6 规定, Promise 对象是一个构造函数, 用来生成 Promise 实例. Promise 构造函数接受一个函数作为参数, 该函数的两个参数分别是 resolve 和 reject. 它们是两个函数, 由 JavaScript 引擎提供, 不用自己部署.
- **resolve 函数的作用**是, 将 Promise 对象的状态从 **'pending' 变为 'resolved'**, 在异步操作成功时调用, 并将异步操作的结果作为参数传递出去.
- **reject 函数的作用**是, 将 Promise 对象的状态从 **'pending' 变为 'rejected'**, 异步操作失败时调用, 并将异步操作的结果作为参数传递出去.
- Promise 实例生成以后, 可以用 then 方法分别指定 resolve 状态和 rejected 状态的回调函数.
  ```javascript
  promise.then(
    function(value) {
      // success
    },
    function(error) {
      // failure
    }
  )
  ```
- then 方法可以接受两个回调函数作为参数. 第一个回调函数是 Promise 对象的状态变为 resolved 时调用, 第二个回调函数是 Promise 对象的状态变为 rejected 时调用. 其中第二个函数是可选的.
- **Promise 新建后就会立即执行**

  ```javascript
  let promise = new Promise((resolve, reject) => {
    console.log('Promise')
    resolve()
  })
  promise.then(() => {
    console.log('resolved')
  })
  console.log('Hi')
  // Promise
  // Hi
  // resolved

  // Promise 新建后立即执行, 所以首先输出的是 Promise. 然后, then 方法指定的回调函数, 将在当前脚本所有同步任务执行完才会执行, 所以 resolved 最后输出.
  ```

- 一般来说, 调用 resolve 或 reject 以后, Promise 的使命就完成了, 后续操作应该放到 then 方法里面, 而不应该直接写在 resolve 或 reject 的后面. 所以, 最好在它们的前面加上 **return** 语句, 这样就不会有意外.

## Promise.prototype.then()

- Promise 实例具有 then 方法, 也就是说, then 方法是定义在原型对象 Promise.prototype 上的. 它的作用是为 Promise 实例添加状态改变时的回调函数. **then 方法的第一个参数是 resolved 状态的回调函数, 第二个参数(可选) 是 rejected 状态的回调函数**.
- then 方法**返回的是一个新的 Promise 实例**(注意,不是原来那个 Promise 实例). 因此可以采用链式写法, 即 then 方法后面再调用另一个 then 方法.
- 可以通过上一个 **Promise** 对象的 then 方法给下一个 **Promise** 对象的 then 方法传递参数。**无论是在上一个 Promise 对象成功的回调参数还是失败的回调参数，都会传递给下一个 Promise 对象成功的回调。**
- 当 Promise 的 then 方法返回的是一个 Promise 对象时， 会将返回的 Promise 的执行结果中的值传递给下一个 then 方法。`newPromise.then()`

## Promise.prototype.catch()

- Promise.prototype.catch 方法是 .then(null, rejection) 或 .then(undefined, rejection) 的别名, 用于指定发生错误时的回调函数.
  ```javascript
  getJSON('/posts.json')
    .then(function(posts) {
      // ...
    })
    .catch(function(error) {
      // 处理 getJSON 和 前一个回调函数运行时发生的错误
      console.log('发生错误！', error)
    })
  /* 上面代码中, getJSON 方法返回一个 Promise 对象, 如果该对象状态变为 resolved, 则会调用 then 方法指定的回调函数; 如果异步操作抛出错误, 状态就变为 rejected, 就会调用 catch 方法指定的回调函数, 处理这个错误. 另外, then 方法指定的回调函数, 如果运行中抛出了错误, 也会被 catch 方法捕获. */
  ```
- 如果 Promise 状态已经变成了 resolved, 再抛出错误是无效的. 因为 Promise 的状态一旦改变, 就永久保存该状态, 不会再变.

- Promise 对象的错误具有'冒泡'性质, 会一直向后传递, 直到被捕获为止. 也就是说, 错误总是被下一个 catch 语句捕获.

- 一般来说, 不要在 then 方法里面定义 reject 状态的回调函数 (即 then 的第二个参数), 总是用 catch 方法.

- 与传统的 try/catch 代码块不同的是, 如果没有使用 catch 方法指定错误处理的回调函数, Promise 对象抛出的错误不会传递到外层代码, 即不会有任何反应. **Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。**

- 一般总是建议，**Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误。**

- **catch** 方法每次执行完毕后会**返回一个新的 Promise** 对象

- 和 **then** 方法一样，无论是在上一个 Promise 对象成功的回调参数还是失败的回调参数，都会传递给下一个 Promise 对象成功的回调。

- 如果 **catch** 方法返回一个 **Promise** 对象，那么会将返回的 Promise 对象的执行结果中的值传递给下一个 catch 方法。**由返回的 Promise 对象的状态来决定失败&成功。**

- **catch 方法， 使用链式编程的原因**

  - 如果 promise 的状态是失败，但是没有对应失败的监听就会报错
  - then 方法会返回一个新的 Promise, 新的 Promise 会继承原有 Promise 的状态
  - 如果新的 promise 状态是失败， 但是没有对应失败的监听也会报错。

## Promise.prototype.finally()

- finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的
- finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally 本质上是 then 方法的特例。

## Promise.all()

- Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
  ```javascript
  const p = Promise.all([p1, p2, p3])
  ```
- Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。
- p 的状态由 p1、p2、p3 决定，分成两种情况
  - 只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数
  - 只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数
- 注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。

## Promise.race()

- Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
  ```javascript
  const p = Promise.race([p1, p2, p3])
  ```
- Promise.race 方法的参数与 Promise.all 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。
- 只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。

## Promise.resolve()

- 将现有对象转换为 Promise 对象, Promise.resolve 方法就起到该作用.
  ```javascript
  Promise.resolve('foo')
  // 等价于
  new Promise(resolve => resolve('foo'))
  ```
- **Promise.resolve 方法的参数分为四种情况**
  - **参数是一个 Promise 实例**. 如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。
  - **参数是一个 thenable 对象**,Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法
  - **参数不是具有 then 方法的对象，或根本就不是对象**, 如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。返回 Promise 实例的状态从一生成就是 resolved，所以回调函数会立即执行。
  - **不带有任何参数**, Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。
- 需要注意的是，**立即 resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时**。

## Promise.reject()

- Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。
- 注意，Promise.reject()方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。这一点与 Promise.resolve 方法不一致。

## Promise.try()

- 模拟 try 代码块, 实现 catch 捕获所有的同步和异步错误.

# generator 生成器

```
function *show() {
    alert('a')
    yield;
    alert('b')
}
let genObj = show(); // Generator 对象
genObj.next()
genObj.next()
```

- 逻辑性

# Math 新增方法

- 3\*\*8-------3 的 8 次方

# Symbol

## 概述

- 一种新的数据类型,独一无二的值. Symbol 值通过 Symbol 函数生成, 也就是说, 对象的属性名现在可以有两种类型, 一种是原来就有的字符串, 另一种就是新增的 Symbol 类型. 凡是属性名属于 Symbol 类型, 就都是独一无二的, 保证不会与其他属性名冲突.

- Symbol 函数前不能使用 new 命令, 否则会报错. 因为 **Symbol 是一个原始类型的值**, 不是对象. 一种类似于字符串的数据类型

- 可以接受一个字符串作为参数, 表示对 Symbol 实例的描述, 主要是为了在控制台显示, 或者转为字符串时, 比较容易区分.

- 如果 Symbol 的参数是一个对象, 就会调用该对象的 toString 方法, 将其转换为字符串, 然后才生成一个 Symbol 值

- **相同参数的 Symbol 函数的返回值是不相等的**

- Symbol 值不能与其他类型的值进行运算.**可以显示转换为字符串**

- Symbol 值也可以转换为布尔值, 但是不能转为数值

- **new: ES2019 新增实例属性 description, 直接返回 Symbol 的描述**

  ```javascript
  const sym = Symbol('foo')
  sym.description // foo
  ```

## 作为属性名的 Symbol

- Symbol 值可以作为标识符, 用于对象的属性名,就能保证不会出现同名的属性.
- **Symbol 值作为对象属性名时, 不能用点运算符**. 因为点运算符后面总是字符串, 所有不会读取 Symbol 作为标识名所指代的那个值. **类型不同, 字符串与 Symbol**

  ```javascript
  const mySymbol = Symbol()
  const a = {}

  a.mySymbol = 'Hello'
  console.log(a[mySymbol]) // undefined
  console.log(a['mySymbol']) // Hello
  ```

- **同理, 在对象的内部, 使用 Symbol 值定义属性时, Symbol 值必须放在方括号之中**

  ```javascript
  let s = Symbol()
  let obj = {
    [s]: function(arg) {
      console.log(arg)
    },
  }
  obj[s](123) // 123
  // 上面代码中,如果 s 不是放在方括号中, 该属性的键名就是字符串 s, 而不是 s 所代表的那个 Symbol 值.

  // 采用增强的对象写法, 上面代码的 obj 对象可以写得更简洁一些
  let s = Symbol()
  let obj = {
    [s](arg) {
      console.log(arg)
    },
  }
  obj[s](13) // 13
  ```

- Symbol 值作为属性名时, 该属性是公共属性,不是私有属性.
- 适合用于消除魔术字符串

## 属性名的遍历

- Symbol 作为属性名, 该属性不会出现在 **for...in, for...of**循环中,也不会被 Object.keys(), Object.getOwnPropertyNames(), JSON.stringify()返回.
- 通过**Object.getOwnPropertySymbols** 方法,返回一个数组,可以获取指定对象的所有 Symbol 属性名.
- Reflect.ownKeys(obj),可以返回一个数组, 包含所有类型的键名, 包括常规键名和 Symbol 键名.

## Symbol.for(), Symbol.keyFor()

- Symbol.for(), 接受一个字符串作为参数,搜索有没有以该参数作为名称的 Symbol 值. 如果有则返回该 Symbol, 否则创建一个新的 Symbol 值.
- **Symbol.for() 与 Symbol() 区别: 前者会被登记在全局环境中供搜索,后者不会.**. Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值, 而是先检查给定的 key 是否已经存在, 如果不存在才会创建一个值.
  ```javascript
  Symbol.for('bar') === Symbol.for('bar') // true
  Symbol('bar') === Symbol('bar') // false
  ```
- Symbol.keyFor(),可以返回一个已登记的 Symbol 类型值的 key
- Symbol.for() 为 Symbol 值登记的名字, 是全局环境, 可以在不同的 iframe 或 service worker 中取到同一个值.

## 内置的 Symbol 值

- Symbol.hasInstance 属性,指向一个内部方法. 当其他对象调用 instanceof 运算符时,判断是否为该对象的实例时,会调用这个方法. 如 foo instanceof Foo 在语言内部, 实际调用 Foo\[Symbol.hasInstance\](foo)

  ```
  class MyClass {
      [Symbol.hasInstance](foo) {
          return foo instanceof Array;
      }
  }

  console.log([1, 2, 3] instanceof new MyClass()); // true
  ```

- Symbol.isConcatSpreadable 等于一个布尔值, 表示该对象用于 Array.prototype.concat() 时,是否可以展开. 数组默认为 true (默认可以展开), 对象为 false
- Symbol.species 属性, 指向一个构造函数. 创建衍生对象时, 使用该属性
- Symbol.match 属性,指向一个函数. 当执行 str.match(myObject) 时, 如果属性存在, 调用并返回该方法的返回值.
- Symbol.replace 属性, 指向一个方法, 当该对象被 String.prototype.replace 方法调用时, 会返回该方法的返回值. 接收两个参数, 第一个参数是 replace 方法正在作用的对象, 第二个参数是替换后的值.
- Symbol.search 属性, 指向一个方法, 当该对象被 String.prototype.search 方法调用时, 会返回该方法的返回值.
- Symbol.split 属性, 指向一个方法, 当该对象被 String.prototype.split 方法调用时,会返回该方法的返回值.
- Symbol.iterator 属性, 指向该对象的默认遍历器方法
- Symbol.toPrimitive 属性, 指向一个方法. 该对象被转为原始类型的值时,会调用这个方法,返回该对象对应的原始类型值.接收一个字符串参数,表示当前运算的模式, Number\String\Default
- Symbol.toStringTag 属性, 指向一个方法.在该对象上调用 Object.prototype.toString 方法时, 如果这个属性存在, 它的返回值会出现在 toString 方法返回的字符串中,表示对象的类型. **这个属性可以用来定制\[object Object\]或\[object Array\] 中 object 后面的那个字符串.**
- Symbol.unscopables 属性, 指向一个对象. 该对象指定了使用 with 关键字时, 哪些属性会被 with 环境排除.

# Proxy

- ES6 原生提供 Proxy 构造函数, 用来生成 Proxy 实例
  ```javascript
  var proxy = new Proxy(target, handler)
  // Proxy 对象的所有用法, 都是上面的这种形式, 不同的只是 handler 参数的写法. 其中, new Proxy() 表示生成一个 Proxy 实例, target 参数表示所要拦截的目标对象, handler 参数也是一个对象,用来定制拦截行为.
  ```
  ```javascript
  var proxy = new Proxy(
    {},
    {
      get: (target, p) => {
        console.log(target, p)
        return 35
      },
    }
  )
  console.log(proxy.time) // 35
  console.log(proxy.name) // 35
  console.log(proxy.title) // 35
  // 上面代码中, 作为构造函数, Proxy 接受两个参数. 第一个参数是所有代码的目标对象(上述为空对象), 即如果没有 Proxy 的介入, 操作原来要访问的就是这个对象; 第二个参数是一个配置对象, 对于每一个被代理的操作, 提供一个对应的处理函数, 拦截对应的操作.
  // get 方法的两个参数分别是目标对象和要访问的属性.
  ```
- **要使得 Proxy 起作用, 必须针对 Proxy 实例进行操作, 而不是针对目标对象进行操作**. 如果 handler 没有设置任何拦截, 那就等同于直接通向原对象

- Proxy 实例也可以作为其他对象的原型对象

  1. ```javascript
     let proxy = new Proxy(
       {},
       {
         get: (target, p) => {
           return 35
         },
       }
     )

     let obj = Object.create(proxy) // 使用现有对象提供新创建对象的__proto__
     console.log(obj.time) // 35
     // proxy 对象是 obj 对象的原型, obj 对象本身并没有 time 属性, 所以根据原型链, 会在 proxy 对象上读取该属性, 导致被拦截.
     ```

- Proxy 支持的拦截操作一览

  - **get(target, propKey, receiver)**:　拦截对象属性的读取，　比如 proxy.foo 和 proxy['foo']
  - **set(target, propKey, value, receiver)**: 拦截对象属性的设置, 比如 proxy.foo = v 或 proxy['foo'] = v, 返回一个布尔值
  - **has (target, propKey)**: 拦截 propKey in proxy 的操作, 返回一个布尔值
  - **deleteProperty(target, propKey)**: 拦截 delete proxy[propKey] 的操作, 返回一个布尔值
  - **ownKeys(target)**:拦截 Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy), for...in 循环, 返回一个数组. 该方法返回目标对象所有自身的属性的属性名, 而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性.
  - **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。
  - **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。
  - **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
  - **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
  - **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
  - **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
  - **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。
  - **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

## Porxy 实例的方法

### get()

- 用于拦截某个属性的读取操作, 可以接受三个参数, 依次是目标对象, 属性名和 proxy 实例本身(严格地说, 是操作行为所针对的对象), 其中最后一个参数可选

  ```javascript
  let person = {
    name: 'zs',
  }
  let proxy = new Proxy(person, {
    get: (target, property) => {
      if (property in target) {
        return target[property]
      } else {
        throw new ReferenceError('Property: ' + property + 'does note exist')
      }
    },
  })

  console.log(proxy.name) // zs
  console.log(proxy.age) // error
  ```

- get 方法可以继承

  ```javascript
  let proxy = new Proxy(
    {},
    {
      get: (target, property, receiver) => {
        console.log('get' + property)
        return target[property]
      },
    }
  )
  let obj = Object.create(proxy)
  obj.foo // getfoo
  ```

- 如果返回 get 方法的第三个参数, 则指向原始的读操作所在的那个对象, 一般情况下就是 Proxy 实例

  ```javascript
  const proxy = new Proxy(
    {},
    {
      get: function(target, property, receiver) {
        return receiver
      },
    }
  )
  proxy.getReceiver === proxy // true
  ```

- 如果一个属性不可配置(configurable) 且不可写(writable), 则 Proxy 不能修改该属性, 否则通过 Proxy 对象访问该属性会报错.

### set()

- set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选

  ```javascript
  let validator = {
    set: (obj, prop, value) => {
      if (prop === 'age') {
        if (!Number.isInteger(value)) {
          throw new TypeError('The age is not an integer')
        }
        if (value > 200) {
          throw new RangeError('The age seems invalid')
        }
      }

      obj[prop] = value // 满足则保存该值
    },
  }

  let person = new Proxy({}, validator)

  person.age = 100
  console.log(person.age) // 100
  person.age = 'you' // error
  person.age = 300 // error
  ```

  > 上面代码中, 由于设置了存值函数 set, 任何不符合要求的 age 属性赋值, 都会抛出一个错误, 这是数据验证的一种实现方法. **利用 set 方法, 还可以数据绑定, 即每当对象发生变化时, 会自动更新 DOM**

- 有时, 会在对象上面设置内部属性, 属性名的第一个字符使用下划线开头, 表示这些属性不应该被外部使用. 结合 get 和 set 方法, 就可以做到防止这些内部属性被外部读写.

  ```javascript
  const handler = {
    get(target, key) {
      invariant(key, 'get')
      return target[key]
    },
    set(target, key, value) {
      invariant(key, 'set')
      target[key] = value
      return true
    },
  }
  function invariant(key, action) {
    if (key[0] === '_') {
      throw new Error(`Invalid attempt to ${action} private "${key}" property`)
    }
  }
  const target = {}
  const proxy = new Proxy(target, handler)
  proxy._prop
  // Error: Invalid attempt to get private "_prop" property
  proxy._prop = 'c'
  // Error: Invalid attempt to set private "_prop" property
  ```

- 如果目标对象自身的某个属性, 不可写且不可配置, 那么 set 方法将不起作用
- 严格模式下, set 代理如果没有返回 true, 就会报错

### apply()

- apply 方法拦截函数的调用, call 和 apply 操作

- apply 方法可以接受三个参数, 分别时目标对象, 目标对象的上下文对象(this) 和 目标对象的参数数组

  ```javascript
  var target = function() {
    return 'I am the target'
  }
  var handler = {
    apply: function() {
      return 'I am the proxy'
    },
  }

  var p = new Proxy(target, handler)

  p()
  // "I am the proxy"
  // 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。
  ```

### has()

- `has`方法用来拦截`HasProperty`操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是`in`运算符

- has 方法可以接受两个参数, 分别是目标对象, 需查询的属性名

  ```javascript
  var handler = {
    has(target, key) {
      if (key[0] === '_') {
        return false
      }
      return key in target
    },
  }
  var target = { _prop: 'foo', prop: 'foo' }
  var proxy = new Proxy(target, handler)
  '_prop' in proxy // false
  ```

- 上面代码中, 如果原对象的属性名的第一个字符是下划线, proxy.has 就会返回 false, 从而不会被 in 运算符发现.

- 如果原对象不可配置或者禁止扩展，这时`has`拦截会报错。
- 值得注意的是，`has`方法拦截的是`HasProperty`操作，而不是`HasOwnProperty`操作，即`has`方法不判断一个属性是对象自身的属性，还是继承的属性。

- 另外，虽然`for...in`循环也用到了`in`运算符，但是`has`拦截对`for...in`循环不生效。

### construct()

- construct 方法用于拦截 new 命令

  ```javascript
  var handler = {
    construct(target, args, newTarget) {
      return new target(...args)
    },
  }
  ```

- 可以接受两个参数:

  - target: 目标对象
  - args: 构造函数的参数对象
  - newTarget: 创建实例对象时, new 命令作用的构造函数(下面例子的 p)

  ```javascript
  var p = new Proxy(function() {}, {
    construct: function(target, args) {
      console.log('called: ' + args.join(', '))
      return { value: args[0] * 10 }
    },
  })

  new p(1).value
  // "called: 1"
  // 10
  ```

- construct 方法返回的必须是一个对象, 否则会报错

### deleteProperty()

- `deleteProperty`方法用于拦截`delete`操作，如果这个方法抛出错误或者返回`false`，当前属性就无法被`delete`命令删除。

- 注意，目标对象自身的不可配置（configurable）的属性，不能被`deleteProperty`方法删除，否则报错

### defineProperty()

- `defineProperty`方法拦截了`Object.defineProperty`操作。

  ```javascript
  var handler = {
    defineProperty(target, key, descriptor) {
      return false
    },
  }
  var target = {}
  var proxy = new Proxy(target, handler)
  proxy.foo = 'bar' // 不会生效
  ```

- 如果目标对象不可扩展（non-extensible），则`defineProperty`不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则`defineProperty`方法不得改变这两个设置。

### getOwnPropertyDescriptor()

- `getOwnPropertyDescriptor`方法拦截`Object.getOwnPropertyDescriptor()`，返回一个属性描述对象或者`undefined`

### getPrototypeOf()

- getPrototypeOf 方法主要用来拦截获取对象原型. 具体拦截下面这些操作

  - `Object.prototype.__proto__`
  - `Object.prototype.isPrototypeOf()`
  - `Object.getPrototypeOf()`
  - `Reflect.getPrototypeOf()`
  - `instanceof`

- getPrototypeOf 方法的返回值必须是对象或者 null, 否则报错. 另外，如果目标对象不可扩展（non-extensible）， `getPrototypeOf`方法必须返回目标对象的原型对象。

### isExtensible()

- 拦截 Object.isExtensible 操作

- 该方法只能返回布尔值，否则返回值会被自动转为布尔值。

### ownKeys()

- `ownKeys`方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。
  - `Object.getOwnPropertyNames()`
  - `Object.getOwnPropertySymbols()`
  - `Object.keys()`
  - `for...in`循环
- 使用 Object.keys 方法时, 有三类属性会被 ownKeys 方法自动过滤, 不会返回
  - 目标对象上不存在的属性
  - 属性名为 Symbol 值
  - 不可遍历（`enumerable`）的属性
- `ownKeys`方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。
- 如果目标对象自身包含不可配置的属性，则该属性必须被`ownKeys`方法返回，否则报错

### preventExtensions()

- `preventExtensions`方法拦截`Object.preventExtensions()`。该方法必须返回一个布尔值，否则会被自动转为布尔值
- 这个方法有一个限制，只有目标对象不可扩展时（即`Object.isExtensible(proxy)`为`false`），`proxy.preventExtensions`才能返回`true`，否则会报错。

### setPrototypeOf()

- `setPrototypeOf`方法主要用来拦截`Object.setPrototypeOf`方法。
- 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），`setPrototypeOf`方法不得改变目标对象的原型

## Proxy.revocable()

- `Proxy.revocable`方法返回一个可取消的 Proxy 实例。

  ```javascript
  let target = {}
  let handler = {}

  let { proxy, revoke } = Proxy.revocable(target, handler)

  proxy.foo = 123
  proxy.foo // 123

  revoke()
  proxy.foo // TypeError: Revoked
  ```

  > `Proxy.revocable`方法返回一个对象，该对象的`proxy`属性是`Proxy`实例，`revoke`属性是一个函数，可以取消`Proxy`实例。上面代码中，当执行`revoke`函数之后，再访问`Proxy`实例，就会抛出一个错误。

- `Proxy.revocable`的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。

## Proxy 与 Reflect 结合使用

```javascript
function Validator(target, validator) {
  return new Proxy(target, {
    _validator: validator,
    set(target, key, value, proxy) {
      // 如果有该属性值
      if (target.hasOwnProperty(key)) {
        // 获取属性验证后返回值
        let va = this._validator[key]
        // true 则更新值
        if (!!va(value)) {
          return Reflect.set(target, key, value, proxy)
        } else {
          throw Error(`不能设置${key}到${value}`)
        }
        // 不存在该属性
      } else {
        throw Error(`${key} 不存在`)
      }
    },
  })
}
const personValidators = {
  name(val) {
    return typeof val === 'string'
  },
  age(val) {
    return typeof val === 'number' && val > 18
  },
  phone(val) {
    return typeof val === 'number' && val.length === 11
  },
}

class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
    this.phone = 18266488847
    return Validator(this, personValidators) // 返回一个Proxy 拦截器
  }
}

let demo = new Person('zs', 18)
```

## this 问题

- 目标对象内部的 `this`关键字会指向 Proxy 代理

## 实例: Web 服务的客户端

- Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端

# Module 的语法

- ES6 模块的设计思想是尽量的静态化, 使得**编译时就能确定模块的依赖关系**, 以及输入和输出的变量. CommonJS 和 AMD 模块, 都**只能在运行时确定这些东西**.
- ES6 模块不是对象, 而是通过 export 命令显示指定输出的代码, 再通过 import 命令输入
- **严格模式: 不应该在顶层代码使用 this**

## export 命令

- export 命令用于规定模块的对外接口, 输出变量
  ```javascript
  let firstName = 'Michael'
  let lastName = 'Jackson'
  let year = 1958
  export { firstName, lastName, year }
  ```
- 除了输出变量, 还可以输出函数或类
- 通常情况下, export 输出的变量就是本来的名字, 但是可以使用 **as 关键字重命名 eg. originName as newName**, 更改名称后，原始名称失效
- 浏览器中实现需要在 script 标签中添加 type="module"

## import 命令

- import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。底层为解构赋值
- import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
- 注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。
- 由于 import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构
  ```javascript
  import { FS, FS1, lastName, year } from './readbook.js'
  ```

## 模块的整体加载

- **(\*) 用星号指定一个对象, 所有输出的值都加载在这个对象上面**
- 模块整体加载所在的那个对象, 是可以静态分析的, 不允许运行时改变.

## export default 命令

- 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。
  ```javascript
  // export-default.js
  export default function() {
    console.log('foo')
  }
  // 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。
  // 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
  ```
- export default 命令用在非匿名函数前，也是可以的.

  ```javascript
  // export-default.js
  export default function foo() {
    console.log('foo')
  }

  // 或者写成

  function foo() {
    console.log('foo')
  }

  export default foo
  // 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载
  ```

- **通过 export default 命令输出模块时, import 时不需要知道原模块的函数名, 并且 import 命令后面, 不使用大括号**

- 一个模块只能有一个默认输出, 因此 export default 命令只能使用一次. 所以 import 命令后面才不用加大括号, 因为只可能唯一对应 export default 命令

- **本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字**. 所以，下面的写法是有效的。

  ```javascript
  // modules.js
  function add(x, y) {
    return x * y
  }
  export { add as default }
  // 等同于
  // export default add;

  // app.js
  import { default as foo } from 'modules'
  // 等同于
  // import foo from 'modules';
  ```

- 因为 export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句。

- 同样,export default 命令本质是将后面的值, 赋给 default 变量, 所以可以直接将一个值写在 export default 之后.

- 可以在 import 语句中, **同时输入默认方法和其他接口.**

- **export default 也可以用来输出类**

- export {}可以与 export default 同时使用

## export 与 import 的复合写法

- 先输入后输出同一个模块, import 语句可以与 export 语句写在一起.
  ```javascript
  export { foo, bar } from 'my_module'
  // 可以简单理解为
  import { foo, bar } from 'my_module'
  export { foo, bar }
  ```
- 写成一行以后, foo 和 bar 实际上并没有被导入当前模块, 只是相当于对外转发了这两个接口, 导致当前模块不能直接使用 foo 和 bar.

## 模块的继承

## 跨模块常量

- const 声命的常量只在当前代码块有效. 如果想设置跨模块的常量, 或者说一个值要被多个模块共享.可以采用下面的写法.

  ```javascript
  // constants.js 模块
  export const A = 1
  export const B = 3
  export const C = 4

  // test1.js 模块
  import * as constants from './constants'
  console.log(constants.A) // 1
  console.log(constants.B) // 3

  // test2.js 模块
  import { A, B } from './constants'
  console.log(A) // 1
  console.log(B) // 3
  ```

## import()

- 引擎处理 import 语句是在编译时, 这时不会去分析或执行 if 语句, 所以 import 语句放在 if 代码块之中毫无意义, 因此会报句法错误, 而不是执行时错误. 也就说, import 和 export 命令只能在模块的顶层, 不能在代码块之中(比如，在 if 代码块之中，或在函数之中)
- 如果 import 命令要取代 Node 的 require 方法，这就形成了一个障碍。因为 require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。
- **提案: 建议引入 import()函数，完成动态加载。**
- import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。

# Module 的加载实现

## 浏览器加载

- 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<script\>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。
- 防止脚本体积过大造成浏览器堵塞, 添加两种异步加载的语法
  - defer: 渲染完再执行
  - async: 下载完就执行
  - 如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。

## 加载规则

- 浏览器加载 ES6 模块, 也使用 script 标签, 但是要加入 **type="module"** 属性。
- **浏览器对于带有 type="module" 的 script, 都是异步加载**, 不会造成堵塞浏览器, 即等到整个页面渲染完, 在执行模块脚本, **等同于打开了 script 标签的 defer 属性.**
- 如果网页有多个<script type="module"\>，它们会按照在页面出现的顺序依次执行。
- <script\>标签的**async**属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染. 一旦使用了 async 属性, <script type="module"\>就不会在页面出现的顺序执行,而是该模块加载完成, 就执行该模块.
- **对于外部的模块脚本, 有几点注意:**
  - 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
  - 模块脚本自动采用严格模式，不管有没有声明 use strict。
  - 模块之中，可以使用 import 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用 export 命令输出对外接口。
  - **模块之中，顶层的 this 关键字返回 undefined，而不是指向 window**。也就是说，在模块顶层使用 this 关键字，是无意义的。
  - 同一个模块如果加载多次，将只执行一次。
- **利用顶层的 this 等于 undefined 这个语法点，可以侦测当前代码是否在 ES6 模块之中**。

## ES6 模块与 CommonJS 模块的差异

**两个重大差异**

- CommonJS 模块输出的是一个**值的拷贝**, ES6 模块输出的是**值得引用**
- CommonJS 模块是**运行时加载**, ES6 模块是**编译时输出接口**
  - 因为 CommonJS 加载的是一个对象(即 module.exports 属性), 该对象只有在脚本运行完才会生成. 而 ES6 模块不是对象, 它的对外接口只是一种静态定义, 在代码解析阶段就会生成.

**解释第一个差异**

- **CommonJS 模块输出的是值的拷贝, 一旦输出一个值，模块内部的变化就影响不到这个值**

  ```javascript
  // readbook.js
  let counter = 3
  function incC() {
    counter++
  }
  module.exports = {
    counter,
    incC,
  }

  // handle.js
  let mod = require('./readbook')
  console.log(mod.counter) // 3
  mod.incC()
  console.log(mod.counter) // 3
  ```

- 上面的代码说明, readbook.js 模块加载以后, 它的内部变化就影响不到输出的 mod.counter 了。这是因为 mod.counter 是一个原始类型的值，会被缓存。除非写成一个函数, 才能得到内部变化后的值.
  ```javascript
  // lib.js
  var counter = 3
  function incCounter() {
    counter++
  }
  module.exports = {
    get counter() {
      return counter
    },
    incCounter: incCounter,
  }
  // 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了
  // $ node main.js
  // 3
  // 4
  ```
- ES6 模块的运行机制与 CommonJS 不同.
  - JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个**只读引用**。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
  - 原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
  - 由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。

## Node 加载

> Node 对 ES6 模块的处理比较麻烦，因为它有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是，将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。

- Node 要求 ES6 模块采用.mjs 后缀文件名。也就是说，只要脚本文件里面使用 import 或者 export 命令，那么就必须采用.mjs 后缀名。
- require 命令不能加载.mjs 文件，会报错，只有 import 命令才可以加载.mjs 文件
- 反过来，.mjs 文件里面也不能使用 require 命令，必须使用 import
- 为了与浏览器的 import 加载规则相同，Node 的.mjs 文件支持 URL 路径。
- 如果模块名不含路径，那么 import 命令会去 node_modules 目录寻找这个模块
- Node 的 import 命令是异步加载，这一点与浏览器的处理方法相同。

## 内部变量

> ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。

- 首先，就是 this 关键字。ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块，这是两者的一个重大差异
- 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。
  - arguments
  - require
  - module
  - exports
  - \_\_filename
  - \_\_dirname

## ES6 模块加载 CommonJS 模块

- CommonJS 模块的输出都定义在 module.exports 这个属性上面. Node 的 import 命令加载 CommonJS 模块，Node 会自动将 module.exports 属性，当作模块的默认输出，即等同于 export default xxx。

  ```javascript
  // a.js
  module.exports = {
    foo: 'hello',
    bar: 'world',
  }

  // 等同于
  export default {
    foo: 'hello',
    bar: 'world',
  }
  ```

- import 命令加载上面的模块，module.exports 会被视为默认输出，即 import 命令实际上输入的是这样一个对象{ default: module.exports }。
- **由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，不允许采用下面的写法。**

  ```javascript
  // 不正确
  import { readFile } from 'fs'

  // 上面的写法不正确，因为fs是 CommonJS 格式，只有在运行时才能确定readFile接口，而import命令要求编译时就确定这个接口。解决方法就是改为整体输入。
  // 正确的写法一
  import * as express from 'express'
  const app = express.default()

  // 正确的写法二
  import express from 'express'
  const app = express()
  ```

## CommonJS 模块加载 ES6 模块

- CommonJS 模块加载 ES6 模块，不能使用 require 命令，而要使用 import()函数。ES6 模块的所有输出接口，会成为输入对象的属性

## 循环加载

- **CommonJS 模块的加载原理**
  - CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。
  ```
  {
    id: '...',
    exports: { ... },
    loaded: true,
    ...
  }
  ```
  - 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。

> 以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。

- **CommonJS 模块的循环加载**

CommonJS 模块的重要特性是加载时执行，即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出

- **ES6 模块的循环加载**

ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用 import 从一个模块加载变量（即 import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值

# Reflect

## Outline

- `Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个

  - 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上. 从`Reflect`对象上可以拿到语言内部的方法。

  - 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。

  - 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。

    ```javascript
    // 老写法
    'assign' in Object // true

    // 新写法
    Reflect.has(Object, 'assign') // true
    ```

  - `Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。

    ```javascript
    Proxy(target, {
      set: function(target, name, value, receiver) {
        var success = Reflect.set(target, name, value, receiver)
        if (success) {
          console.log('property ' + name + ' on ' + target + ' set to ' + value)
        }
        return success
      },
    })
    // 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。
    ```

## 静态方法

- Reflect.apply(target, thisArg, args)
- Reflect.construct(target, args)
- Reflect.get(target, name, receiver)
- Reflect.set(target, name, value, receiver)
- Reflect.defineProperty(target, name, desc)
- Reflect.deleteProperty(target, name)
- Reflect.has(target, name)
- Reflect.ownKeys(target)
- Reflect.isExtensible(target)
- Reflect.preventExtensions(target)
- Reflect.getOwnPropertyDescriptor(target, name)
- Reflect.getPrototypeOf(target)
- Reflect.setPrototypeOf(target, prototype)

上面这些方法的作用，大部分与`Object`对象的同名方法的作用都是相同的，而且它与`Proxy`对象的方法是一一对应的。

### Reflect.get(target, name, receiver)

`Reflect.get`方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar
  },
}

Reflect.get(myObject, 'foo') // 1
Reflect.get(myObject, 'bar') // 2
Reflect.get(myObject, 'baz') // 3
```

如果`name`属性部署了读取函数（getter），则读取函数的`this`绑定`receiver`。

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar
  },
}

var myReceiverObject = {
  foo: 4,
  bar: 4,
}

Reflect.get(myObject, 'baz', myReceiverObject) // 8
```

如果第一个参数不是对象，`Reflect.get`方法会报错。

```javascript
Reflect.get(1, 'foo') // 报错
Reflect.get(false, 'foo') // 报错
```

### Reflect.set(target, name, value, receiver)

`Reflect.set`方法设置`target`对象的`name`属性等于`value`。

```javascript
var myObject = {
  foo: 1,
  set bar(value) {
    return (this.foo = value)
  },
}

myObject.foo // 1

Reflect.set(myObject, 'foo', 2)
myObject.foo // 2

Reflect.set(myObject, 'bar', 3)
myObject.foo // 3
```

如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`

如果第一个参数不是对象，`Reflect.set`会报错。

### Reflect.has(obj, name)

- `Reflect.has`方法对应`name in obj`里面的`in`运算符。

  ```javascript
  var myObject = {
    foo: 1,
  }

  // 旧写法
  'foo' in myObject // true

  // 新写法
  Reflect.has(myObject, 'foo') // true
  ```

- 如果`Reflect.has()`方法的第一个参数不是对象，会报错。

### Reflect.deleteProperty(obj, name)

- `Reflect.deleteProperty`方法等同于`delete obj[name]`，用于删除对象的属性。

  ```javascript
  const myObj = { foo: 'bar' }

  // 旧写法
  delete myObj.foo

  // 新写法
  Reflect.deleteProperty(myObj, 'foo')
  ```

- 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回`true`；删除失败，被删除的属性依然存在，返回`false`。

- 如果`Reflect.has()`方法的第一个参数不是对象，会报错。

### Reflect.construct(target, args)

- `Reflect.construct`方法等同于`new target(...args)`，这提供了一种不使用`new`，来调用构造函数的方法

  ```javascript
  function Greeting(name) {
    this.name = name
  }

  // new 的写法
  const instance = new Greeting('张三')

  // Reflect.construct 的写法
  const instance = Reflect.construct(Greeting, ['张三'])
  ```

- 如果`Reflect.construct()`方法的第一个参数不是函数，会报错

### Reflect.getPrototypeOf(obj)

- `Reflect.getPrototypeOf`方法用于读取对象的`__proto__`属性，对应`Object.getPrototypeOf(obj)`

  ```javascript
  const myObj = new FancyThing()

  // 旧写法
  Object.getPrototypeOf(myObj) === FancyThing.prototype

  // 新写法
  Reflect.getPrototypeOf(myObj) === FancyThing.prototype
  ```

- `Reflect.getPrototypeOf`和`Object.getPrototypeOf`的一个区别是，如果参数不是对象，`Object.getPrototypeOf`会将这个参数转为对象，然后再运行，而`Reflect.getPrototypeOf`会报错

### Reflect.setPrototypeOf(obj, newProto)

- `Reflect.setPrototypeOf`方法用于设置目标对象的原型（prototype），对应`Object.setPrototypeOf(obj, newProto)`方法。它返回一个布尔值，表示是否设置成功

  ```javascript
  const myObj = {}

  // 旧写法
  Object.setPrototypeOf(myObj, Array.prototype)

  // 新写法
  Reflect.setPrototypeOf(myObj, Array.prototype)

  myObj.length // 0
  ```

- 如果无法设置目标对象的原型（比如，目标对象禁止扩展），`Reflect.setPrototypeOf`方法返回`false`。
- 如果第一个参数不是对象，`Object.setPrototypeOf`会返回第一个参数本身，而`Reflect.setPrototypeOf`会报错

- 如果第一个参数是`undefined`或`null`，`Object.setPrototypeOf`和`Reflect.setPrototypeOf`都会报错。

### Reflect.apply(func, thisArg, args)

- `Reflect.apply`方法等同于`Function.prototype.apply.call(func, thisArg, args)`，用于绑定`this`对象后执行给定函数。

  ```javascript
  const ages = [11, 33, 12, 54, 18, 96]

  // 旧写法
  const youngest = Math.min.apply(Math, ages)
  const oldest = Math.max.apply(Math, ages)
  const type = Object.prototype.toString.call(youngest)

  // 新写法
  const youngest = Reflect.apply(Math.min, Math, ages)
  const oldest = Reflect.apply(Math.max, Math, ages)
  const type = Reflect.apply(Object.prototype.toString, youngest, [])
  ```

### Reflect.defineProperty(target, propertyKey, attributes)

- `Reflect.defineProperty`方法基本等同于`Object.defineProperty`，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用`Reflect.defineProperty`代替它

  ```javascript
  function MyDate() {
    /*…*/
  }

  // 旧写法
  Object.defineProperty(MyDate, 'now', {
    value: () => Date.now(),
  })

  // 新写法
  Reflect.defineProperty(MyDate, 'now', {
    value: () => Date.now(),
  })
  ```

- 如果`Reflect.defineProperty`的第一个参数不是对象，就会抛出错误，比如`Reflect.defineProperty(1, 'foo')`。

### Reflect.getOwnPropertyDescriptor(target, propertyKey)

- `Reflect.getOwnPropertyDescriptor`基本等同于`Object.getOwnPropertyDescriptor`，用于得到指定属性的描述对象，将来会替代掉后者。

  ```javascript
  var myObject = {}
  Object.defineProperty(myObject, 'hidden', {
    value: true,
    enumerable: false,
  })

  // 旧写法
  var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden')

  // 新写法
  var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden')
  ```

- `Reflect.getOwnPropertyDescriptor`和`Object.getOwnPropertyDescriptor`的一个区别是，如果第一个参数不是对象，`Object.getOwnPropertyDescriptor(1, 'foo')`不报错，返回`undefined`，而`Reflect.getOwnPropertyDescriptor(1, 'foo')`会抛出错误，表示参数非法

### Reflect.isExtensible(target)

- `Reflect.isExtensible`方法对应`Object.isExtensible`，返回一个布尔值，表示当前对象是否可扩展。

  ```javascript
  const myObject = {}

  // 旧写法
  Object.isExtensible(myObject) // true

  // 新写法
  Reflect.isExtensible(myObject) // true
  ```

- 如果参数不是对象，`Object.isExtensible`会返回`false`，因为非对象本来就是不可扩展的，而`Reflect.isExtensible`会报错

### Reflect.preventExtensions(target)

- `Reflect.preventExtensions`对应`Object.preventExtensions`方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。

  ```javascript
  var myObject = {}

  // 旧写法
  Object.preventExtensions(myObject) // Object {}

  // 新写法
  Reflect.preventExtensions(myObject) // true
  ```

- 如果参数不是对象，`Object.preventExtensions`在 ES5 环境报错，在 ES6 环境返回传入的参数，而`Reflect.preventExtensions`会报错

### Reflect.ownKeys(target)

- `Reflect.ownKeys`方法用于返回对象的所有属性，基本等同于`Object.getOwnPropertyNames`与`Object.getOwnPropertySymbols`之和。

- 如果`Reflect.ownKeys()`方法的第一个参数不是对象，会报错。

# Set 和 Map 数据结构

## Set

### 基本用法

- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

- `Set`本身是一个构造函数，用来生成 Set 数据结构。

  ```javascript
  const s = new Set()

  ;[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x))

  for (let i of s) {
    console.log(i)
  }
  // 2 3 5 4
  // 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值
  ```

- `Set`函数可以接受一个**数组**（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

- 一种去除数组重复成员的方法。(**数组去重**)

  ```javascript
  ;[...new Set(array)]
  ```

- 去除字符串里面的重复字符

  ```javascript
  ;[...new Set('ababbc')].join('')
  // "abc"
  ```

- 向 Set 加入值的时候，**不会发生类型转换**，所以`5`和`"5"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），**主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身**。

- 两个对象总是不相等的

### Set 实例的属性和方法

Set 结构的实例有以下属性。

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数

Set 实例的方法分为两大类：**操作方法**（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

- `add(value)`：添加某个值，返回 Set 结构本身。
- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `clear()`：清除所有成员，没有返回值

**Array.from**方法可以将 Set 结构转为数组

- 另一种数组去重的方法

  ```javascript
  function dedupe(array) {
    return Array.from(new Set(array))
  }

  dedupe([1, 1, 2, 3]) // [1, 2, 3]
  ```

### 遍历操作

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

需要特别指出的是，**`Set`的遍历顺序就是插入顺序**。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

1. **keys()，values()，entries()**

   `keys`方法、`values`方法、`entries`方法返回的都是遍历器对象. 由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。

   ```javascript
   let set = new Set(['red', 'green', 'blue'])

   for (let item of set.keys()) {
     console.log(item)
   }
   // red
   // green
   // blue

   for (let item of set.values()) {
     console.log(item)
   }
   // red
   // green
   // blue

   for (let item of set.entries()) {
     console.log(item)
   }
   // ["red", "red"]
   // ["green", "green"]
   // ["blue", "blue"]
   // 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。
   ```

   - Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。

     ```javascript
     Set.prototype[Symbol.iterator] === Set.prototype.values
     // true
     ```

   - 这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。

     ```javascript
     let set = new Set(['red', 'green', 'blue'])

     for (let x of set) {
       console.log(x)
     }
     // red
     // green
     // blue
     ```

2. forEach()

   - Set 结构的实例与数组一样，也拥有`forEach`方法，用于对每个成员执行某种操作，没有返回值
   - 该函数的参数与数组的`forEach`一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。
   - `forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象

3. 遍历的应用

   - 扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。

   - 数组的`map`和`filter`方法也可以间接用于 Set

   - 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。

     ```javascript
     // 方法一
     let set = new Set([1, 2, 3])
     set = new Set([...set].map(val => val * 2))
     // set的值是2, 4, 6

     // 方法二
     let set = new Set([1, 2, 3])
     set = new Set(Array.from(set, val => val * 2))
     // set的值是2, 4, 6
     ```

## WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

- 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
- 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

**垃圾回收机制**

- 因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。
- 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。
- **WeakSet 里面的引用，都不计入垃圾回收机制**，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

- 由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。
- 另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 **ES6 规定 WeakSet 不可遍历**。

- 这些特点同样适用于 WeakMap 结构。

### 语法

- WeakSet 是一个构造函数，可以使用`new`命令，创建 WeakSet 数据结构。

  ```javascript
  const ws = new WeakSet()
  ```

- 作为构造函数，WeakSet 可以**接受一个数组或类似数组的对象作为参数**。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。

  ```javascript
  const a = [
    [1, 2],
    [3, 4],
  ]
  const ws = new WeakSet(a)
  // WeakSet {[1, 2], [3, 4]}
  ```

- 上面代码中，`a`是一个数组，它有两个成员，也都是数组。将`a`作为 WeakSet 构造函数的参数，`a`的成员会自动成为 WeakSet 的成员。

- 注意，是`a`数组的成员成为 WeakSet 的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。

  ```javascript
  const b = [3, 4]
  const ws = new WeakSet(b)
  // Uncaught TypeError: Invalid value used in weak set(…)
  // 上面代码中，数组b的成员不是对象，加入 WeaKSet 就会报错。
  ```

WeakSet 结构有以下三个方法。

- **WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。
- **WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。
- **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中

- **WeakSet 没有`size`属性，没有办法遍历它的成员。**

- WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

## Map

### 含义和基本用法

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

```javascript
const data = {}
const element = document.getElementById('myDiv')

data[element] = 'metadata'
data['[object HTMLDivElement]'] // "metadata"
// 上面代码原意是将一个 DOM 节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。
```

为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，**Map 结构提供了“值—值”的对应**，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```javascript
const m = new Map()
const o = { p: 'Hello World' }

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false
// 上面代码使用 Map 结构的set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。
```

作为构造函数，Map 也可以接受一个数组作为参数。该数组的**成员是一个个表示键值对的数组**。

```javascript
const map = new Map([
  ['name', '张三'],
  ['title', 'Author'],
])

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```

上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。

`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

```javascript
const items = [
  ['name', '张三'],
  ['title', 'Author'],
]

const map = new Map()

items.forEach(([key, value]) => map.set(key, value))
```

事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作`Map`构造函数的参数。这就是说，**`Set`和`Map`都可以用来生成新的 Map。**

**如果对同一个键多次赋值，后面的值将覆盖前面的值。**

**如果读取一个未知的键，则返回`undefined`。**

**注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。**

```javascript
const map = new Map()

map.set(['a'], 555)
map.get(['a']) // undefined
// 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined
```

**同理，同样的值的两个实例，在 Map 结构中被视为两个键。**

```javascript
const map = new Map()

const k1 = ['a']
const k2 = ['a']

map.set(k1, 111).set(k2, 222)

map.get(k1) // 111
map.get(k2) // 222
// 上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键
```

> 由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键

```javascript
let map = new Map()

map.set(-0, 123)
map.get(+0) // 123

map.set(true, 1)
map.set('true', 2)
map.get(true) // 1

map.set(undefined, 3)
map.set(null, 4)
map.get(undefined) // 3

map.set(NaN, 123)
map.get(NaN) // 123
```

### 实例的属性和操作方法

Map 结构的实例有以下属性和操作方法。

1. **size** **属性**

   `size`属性返回 Map 结构的成员总数。

2. **set(key, value)**

   `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

   `set`方法**返回的是当前的`Map`对象**，因此可以采用**链式写法。**

3. **get(key)**

   `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

4. **has(key)**

   `has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中

   ```javascript
   const m = new Map()

   m.set('edition', 6)
   m.set(262, 'standard')
   m.set(undefined, 'nah')

   m.has('edition') // true
   m.has('years') // false
   m.has(262) // true
   m.has(undefined) // true
   ```

5. **delete(key)**

   `delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

6. **clear()**

   clear 方法清除所有成员, 没有返回值

   ```javascript
   let map = new Map()
   map.set('foo', true)
   map.set('bar', false)

   map.size // 2
   map.clear()
   map.size // 0
   ```

### 遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回所有成员的遍历器。
- `forEach()`：遍历 Map 的所有成员。

```javascript
for (let [key, value] of map.entries()) {
  console.log(key, value)
}
// "F" "no"
// "T" "yes"

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value)
}
// "F" "no"
// "T" "yes"
```

上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。

```javascript
map[Symbol.iterator] === map.entries
// true
```

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）

```javascript
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
```

结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。

```javascript
const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c')

const map1 = new Map([...map0].filter(([k, v]) => k < 3))
// 产生 Map 结构 {1 => 'a', 2 => 'b'}

const map2 = new Map([...map0].map(([k, v]) => [k * 2, '_' + v]))
// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
```

Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。

```javascript
map.forEach(function(value, key, map) {
  console.log('Key: %s, Value: %s', key, value)
})
```

`forEach`方法还可以接受第二个参数，用来绑定`this`。

### 与其他数据结构的互相转换

1. **Map 转为数组**

   Map 转为数组最方便的方法，就是使用扩展运算符（`...`）

2. **数组转为 Map**

   **将数组传入 Map 构造函数，就可以转为 Map**。

   ```javascript
   new Map([
     [true, 7],
     [{ foo: 3 }, ['abc']],
   ])
   // Map {
   //   true => 7,
   //   Object {foo: 3} => ['abc']
   // }
   ```

3. **Map 转为对象**

   如果所有 Map 的键都是字符串, 它可以无损地转为对象, 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。`for...of`

   ```javascript
   const map = new Map([
     ['demo', 'demotest'],
     ['age', 29],
     ['score', 99],
   ])
   const obj = Object.create(null) // {}
   for (let [k, v] of map) {
     obj[k] = v
   }
   ```

4. **对象转为 Map**

   `for...of, map.set()`

   ```javascript
   const obj2 = {
     demo: 'demotest',
     age: 29,
     score: 99,
   }
   const map = new Map()
   for (let k of Object.keys(obj2)) {
     map.set(k, obj2[k])
   }
   console.log(map)
   ```

5. **Map 转为 JSON**

   `for...of`, 设置对应的 key, value

   ```javascript
   const map = new Map([
     ['demo', 'demotest'],
     ['age', 29],
     ['score', 99],
   ])
   const obj = Object.create(null) // {}
   for (let [k, v] of map) {
     obj[k] = v
   }
   let json = JSON.stringify(obj)
   console.log(json)
   // 先转为对象再用 JSON.stringify()方法
   ```

   如果 Map 的键名有非字符串, 这时可以选择转为数组 JSON

   ```javascript
   JSON.stringify([...map])
   ```

6. **JSON 转为 Map**

   正常情况下, 所有键名都是字符串

   ```javascript
   const obj2 = {
     demo: 'demotest',
     age: 29,
     score: 99,
   }

   const map = new Map()
   for (let k of Object.keys(obj2)) {
     map.set(k, obj2[k])
   }
   console.log(map) // Map { 'demo' => 'demotest', 'age' => 29, 'score' => 99 }
   ```

   **有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。**

   ```javascript
   function jsonToMap(jsonStr) {
     return new Map(JSON.parse(jsonStr))
   }

   jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
   // Map {true => 7, Object {foo: 3} => ['abc']}
   ```

## WeakMap

### 含义

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

- `WeakMap`与`Map`的区别有两点

  - `WeakMap`**只接受对象作为键名**（`null`除外），不接受其他类型的值作为键名。

    ```javascript
    const map = new WeakMap()
    map.set(1, 2)
    // TypeError: 1 is not an object!
    map.set(Symbol(), 2)
    // TypeError: Invalid value used as weak map key
    map.set(null, 2)
    // TypeError: Invalid value used as weak map key
    ```

- `WeakMap`的键名所指向的对象，不计入垃圾回收机制

- **WeakMap 解决内存泄漏问题, 方便垃圾回收机制. **

  ```javascript
  const wm = new WeakMap()

  const element = document.getElementById('example')

  wm.set(element, 'some information')
  wm.get(element) // "some information"
  ```

`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏

**注意: WeakMap 弱引用的只是键名, 而不是键值. 键值依然是正常引用**

```javascript
const wm = new WeakMap()
let key = {}
let obj = { foo: 1 }

wm.set(key, obj)
obj = null
wm.get(key)
// Object {foo: 1}
// 上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。
```

### WeakMap 的语法

WeakMap 与 Map 在 API 上的区别主要是两个

- 没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性

- 无法清空，即不支持`clear`方法

`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`

## Set 与 Map 对比

| 属性\方法       | Set                                                                 | Map                                               |
| :-------------- | :------------------------------------------------------------------ | :------------------------------------------------ |
| 基本介绍        | new Set(), 类似数组, **值唯一**, 无类型转换                         | new map(), 键值对集合, 值-值对应                  |
| 添加成员        | set.**add(value)**, 返回 Set 结构本身                               | map.**set(key,value)**, 覆盖同名值, 返回 Map 本身 |
| 删除成员        | set.**delete(value)**, 返回 Boolean                                 | map.**delete(key)**, 返回 Boolean                 |
| 是否有成员      | set.**has(value)**, 返回 Boolean                                    | map.**has(key)**, 返回 Boolean                    |
| 清除所有        | set.**clear()**                                                     | map.**clear()**                                   |
| 成员总数        | set.**size**, 返回总数                                              | map.**size**,返回总数                             |
| 读取成员        |                                                                     | map.**get(key)**, 如果找不到 key, 返回 undefined  |
| **遍历操作**    |                                                                     |                                                   |
| keys()          | `keys`方法和`values`方法的行为完全一致                              | `keys()`：返回键名的遍历器                        |
| values()        | keys`方法和`values`方法的行为完全一致 |`values()`：返回键值的遍历器 |
| entries()       | 两个成员完全相等                                                    | `entries()`：返回所有成员的遍历器                 |
| forEach()       | 参数分别是(value,key, set)                                          | 参数分别是(value,key, map)                        |
| 扩展运算符(...) | [...set], Array.from(set) 转为数组                                  | [...map]                                          |

## Array && Map && Set

| 属性/方法 | Array                 | Map                | Set               |
| :-------- | :-------------------- | ------------------ | ----------------- |
| 增        | array.push(val)       | map.set(key,value) | set.add(value)    |
| 查        | array.find()          | map.has(key)       | set.has(value)    |
| 改        | array.forEach()       | map.set(key,value) | set.forEach()     |
| 删        | array.splice(index,1) | map.delete(key)    | set.delete(value) |

## Object && Map && Set

| 属性/方法 | Object             | Map                | Set               |
| :-------- | :----------------- | ------------------ | ----------------- |
| 增        | object[key]=value  | map.set(key,value) | set.add(value)    |
| 查        | key in object      | map.has(key)       | set.has(value)    |
| 改        | object[key]=value  | map.set(key,value) | set.forEach()     |
| 删        | delete object[key] | map.delete(key)    | set.delete(value) |

# Iterator 和 for...of 循环

- **一个数据结构只要有`Symbol.iterator`属性, 就可以遍历**
- **`Symbol.iterator`属性本身是一个函数(当前数据结构默认的遍历器生成函数), 执行该函数, 返回一个遍历器对象**
- **执行对象的 next()方法, 返回一个对象, 表示当前数据成员的信息. 该对象具有 `value`和`done`两个属性, `value`属性返回当前位置的成员,`done`属性是一个布尔值,表示遍历是否结束.**
- **调用指针对象的`next`方法, 就可以遍历实先给定的数据结构**

## Iterator(遍历器)的概念

JavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

**Iterator 的遍历过程**

- 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象
- 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。

- 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员
- 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。

```javascript
var it = makeIterator(['a', 'b'])

it.next() // { value: "a", done: false }
it.next() // { value: "b", done: false }
it.next() // { value: undefined, done: true }

function makeIterator(array) {
  var nextIndex = 0
  return {
    next: function() {
      return nextIndex < array.length ? { value: array[nextIndex++], done: false } : { value: undefined, done: true }
    },
  }
}
```

Iterator 只是把接口规格加到数据结构之上, 所以, 遍历器与它所遍历的那个数据结构, 实际上是分开的.

对于遍历器对象来说，`done: false`和`value: undefined`属性都是可以省略的

## 默认 Iterator 接口

Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即`for...of`循环. 当使用`for...of`循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。

一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）

**ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）**。**`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。**至于属性名`Symbol.iterator`，它是一个表达式，返回`Symbol`对象的`iterator`属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内

```javascript
const obj = {
  [Symbol.iterator]: function() {
    return {
      next: function() {
        return {
          value: 1,
          done: true,
        }
      },
    }
  },
}
// 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。

let a = {
    name: 4,
    [Symbol.iterator]() {
        let name = this.name
        return {
            next() {
                if (name <= 0) {
                    return { value: undefined, done: true }
                } else {
                    return { value: name--, done: false }
                }
            },
        }
    },
}
for (let c of a) {
    console.log(c);
}
```

原生具备 Iterator 接口的数据结构如下

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象

```javascript
// 数组的Symbol.iterator属性
let arr = ['a', 'b', 'c']
let iter = arr[Symbol.iterator]()

iter.next() // { value: 'a', done: false }
iter.next() // { value: 'b', done: false }
iter.next() // { value: 'c', done: false }
iter.next() // { value: undefined, done: true }
// 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。
```

除了原生部署的 Iterator 接口的数据结构, 不用自己写遍历器生成函数, 其他数据结构(主要是对象), 都需要自己在 Symbol.iterator 属性上面部署. 这样才会被 for...of 循环遍历

```javascript
class RangeIterator {
  constructor(start, stop) {
    this.value = start
    this.stop = stop
  }

  [Symbol.iterator]() {
    return this
  }
  // 具有Symbol.iterator属性, 会返回一个遍历器对象,该对象具有next()方法.返回 value 与 done 属性

  next() {
    var value = this.value
    if (value < this.stop) {
      this.value++
      return { done: false, value: value }
    }
    return { done: true, value: undefined }
  }
}

function range(start, stop) {
  return new RangeIterator(start, stop)
}

for (var value of range(0, 3)) {
  console.log(value) // 0, 1, 2
}
// 上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。
```

```javascript
class RangeIterator {
  constructor(start, stop) {
    this.value = start
    this.stop = stop
  }

  [Symbol.iterator]() {
    return this
  }

  next() {
    var value = this.value
    if (value < this.stop) {
      this.value++
      return {
        done: false,
        value: value,
      }
    }
    return {
      done: true,
      value: undefined,
    }
  }
}

let a = new RangeIterator(0, 3)
let a1 = a.next()
let a2 = a.next()
let a3 = a.next()
let a4 = a.next()
console.log(a1, a2, a3, a4)
// { done: false, value: 0 }
// { done: false, value: 1 }
// { done: false, value: 2 }
// { done: true, value: undefined }
```

- 对于类似数组的对象（存在数值键名和`length`属性），部署 Iterator 接口，有一个简便方法，就是`Symbol.iterator`方法直接引用数组的 Iterator 接口。

  ```javascript
  NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]
  // 或者
  NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]
  ;[...document.querySelectorAll('div')] // 可以执行了
  ```

## **调用 Iterator 接口的场合**

1. **解构赋值**
2. **扩展运算符**----只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。
3. **yield\***
4. **其他场合**
   - for...of
   - Array.from()
   - Map(), Set(), WeakMap(), WeakSet()（比如`new Map([['a',1],['b',2]])`）
   - Promise.all()
   - Promise.race()

## 字符串的 Iterator 接口

字符串是一个类似数组的对象，也原生具有 Iterator 接口。

**可以覆盖原生的`Symbol.iterator`方法，达到修改遍历器行为的目的。**

## Iterator 接口与 Generator 函数

```javascript
let myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
}
[...myIterable] // [1, 2, 3]

// 或者采用下面的简洁写法

let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

for (let x of obj) {
  console.log(x);
}
// "hello"
// "world"
```

## 遍历对象的 return(), throw()

遍历器对象除了具有`next`方法，还可以具有`return`方法和`throw`方法。如果你自己写遍历器对象生成函数，那么**`next`方法是必须部署的**，`return`方法和`throw`方法是否部署是可选的。

> `return`方法的使用场合是，如果`for...of`循环提前退出（通常是因为出错，或者有`break`语句），就会调用`return`方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署`return`方法。

> 注意，`return`方法必须返回一个对象，这是 Generator 规格决定的。`throw`方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法

## for...of 循环

一个数据结构只要部署了`Symbol.iterator`属性，就被视为具有 iterator 接口，就可以用`for...of`循环遍历它的成员。也就是说，`for...of`循环内部调用的是数据结构的`Symbol.iterator`方法。

`for...of`循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如`arguments`对象、DOM NodeList 对象）、 Generator 对象，以及字符串

- `for...of`循环可以代替数组实例的`forEach`方法
- Set 和 Map 结构原生具有 Iterator 接口, 可以直接使用 `for...of`循环
- 对于普通的对象，`for...of`结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，`for...in`循环依然可以用来遍历键名。一种解决方法是，**使用`Object.keys`方法将对象的键名生成一个数组**，然后遍历这个数组。
- 其他的遍历方式:
  - for
  - forEach: 无法中途跳出`forEach`循环，`break`命令或`return`命令都不能奏效。
  - `for...in` 专为遍历对象而设计
  - for...of, 简洁, 可以 break, continue 和 return 配合使用, 提供了遍历所有数据结构的统一操作接口.

# Generator 函数的语法

## Outline

- 一种异步编程解决方案, Generator 函数是一个状态机, 封装了多个内部状态, 返回一个**遍历器对象**

- **函数特征**: `function`关键字与函数名之间有一个**星号**; 函数体内使用**yield**表达式, 定义不同的内部状态

- Generator 函数的**调用方法与普通函数一样**，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个**指向内部状态的指针对象(Iterator Object)**

- **调用遍历器对象的`next`方法，使得指针移向下一个状态**。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，**直到遇到下一个`yield`表达式（或`return`语句）为止**。换言之，Generator 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。

  ```javascript
  function* helloWorldGenerator() {
    yield 'hello'
    yield 'world'
    return 'ending'
  }

  var hw = helloWorldGenerator()

  hw.next()
  // { value: 'hello', done: false }

  hw.next()
  // { value: 'world', done: false }

  hw.next()
  // { value: 'ending', done: true }

  hw.next()
  // { value: undefined, done: true }
  ```

- 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。**`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束**

## yield 表达式

由于 Generator 函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`表达式就是暂停标志。

1. 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。
2. 下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。
3. 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。
4. 如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

需要注意的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

**每次遇到`yield`，函数暂停执行**，下一次再从该位置继续向后执行，**而`return`语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）`return`语句**，但是可以执行多次（或者说多个）`yield`表达式。正常函数只能返回一个值，因为只能执行一次`return`；**Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。**

Generator 函数可以不用`yield`表达式，这时就变成了一个单纯的暂缓执行函数。

```javascript
function* f() {
  console.log('执行了！')
}

var generator = f()

setTimeout(function() {
  generator.next()
}, 2000)
// 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个 Generator 函数，就变成只有调用next方法时，函数f才会执行。
```

- `yield`表达式如果用在另一个表达式之中，必须放在圆括号里面。
- `yield`表达式用作函数参数或放在赋值表达式的右边，可以不加括号。

## 与 Iterator 接口的关系

- 任意一个对象的 `Symbol.iterator`方法, 等于该对象的遍历器生成函数, 调用该函数会返回该对象的一个遍历器对象.

- 因为 Generator 函数就是遍历器生成函数, 因此可以把 Generator 赋值给对象的 `Symbol.iterator`属性, 从而使得该对象具有 Iterator 接口.

- Generator 函数执行后，返回一个遍历器对象。**该对象本身也具有`Symbol.iterator`属性，执行后返回自身。**

## next 方法的参数

- `yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，**该参数就会被当作上一个`yield`表达式的返回值**。

  ```javascript
  function* foo(x) {
    var y = 2 * (yield x + 1)
    var z = yield y / 3
    return x + y + z
  }

  var a = foo(5)
  a.next() // Object{value:6, done:false}
  a.next() // Object{value:NaN, done:false}
  a.next() // Object{value:NaN, done:true}

  var b = foo(5)
  b.next() // { value:6, done:false }
  b.next(12) // { value:8, done:false }
  b.next(13) // { value:42, done:true }
  ```

  上面代码中，第二次运行`next`方法的时候不带参数，导致 y 的值等于`2 * undefined`（即`NaN`），除以 3 以后还是`NaN`，因此返回对象的`value`属性也等于`NaN`。第三次运行`Next`方法的时候不带参数，所以`z`等于`undefined`，返回对象的`value`属性等于`5 + NaN + undefined`，即`NaN`。

  如果向`next`方法提供参数，返回结果就完全不一样了。上面代码第一次调用`b`的`next`方法时，返回`x+1`的值`6`；第二次调用`next`方法，将上一次`yield`表达式的值设为`12`，因此`y`等于`24`，返回`y / 3`的值`8`；第三次调用`next`方法，将上一次`yield`表达式的值设为`13`，因此`z`等于`13`，这时`x`等于`5`，`y`等于`24`，所以`return`语句的值等于`42`。

## for...of 循环

`for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象，且此时不再需要调用`next`方法。

```javascript
function* foo() {
  yield 1
  yield 2
  yield 3
  yield 4
  yield 5
  return 6
}

for (let v of foo()) {
  console.log(v)
}
// 1 2 3 4 5
```

上面代码使用`for...of`循环，依次显示 5 个`yield`表达式的值。这里需要注意，**一旦`next`方法的返回对象的`done`属性为`true`，`for...of`循环就会中止，且不包含该返回对象，所以上面代码的`return`语句返回的`6`，不包括在`for...of`循环之中。**

## Generator.prototype.throw()

Generator 函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。

```javascript
var g = function*() {
  try {
    yield
  } catch (e) {
    console.log('内部捕获', e)
  }
}

var i = g()
i.next()

try {
  i.throw('a')
  i.throw('b')
} catch (e) {
  console.log('外部捕获', e)
}
// 内部捕获 a
// 外部捕获 b
```

`throw`方法抛出的错误**要被内部捕获，前提是必须至少执行过一次`next`方法**。因为第一次执行`next`方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时`throw`方法抛错只可能抛出在函数外部。

`throw`方法被捕获以后，会附带执行下一条`yield`表达式。也就是说，会附带执行一次`next`方法。

```javascript
var gen = function* gen() {
  try {
    yield console.log('a')
  } catch (e) {
    // ...
  }
  yield console.log('b')
  yield console.log('c')
}

var g = gen()
g.next() // a
g.throw() // b
g.next() // c
// 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。
```

## Generator.prototype.return()

Generator 函数返回的遍历器对象，还有一个`return`方法，可以返回给定的值，并且终结遍历 Generator 函数

```javascript
function* gen() {
  yield 1
  yield 2
  yield 3
}

var g = gen()

g.next() // { value: 1, done: false }
g.return('foo') // { value: "foo", done: true }
g.next() // { value: undefined, done: true }
// 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator 函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。
```

如果 Generator 函数内部有`try...finally`代码块，且正在执行`try`代码块，那么`return`方法会推迟到`finally`代码块执行完再执行。

## next() throw() return() 的共同点

作用都是让 Generator 函数恢复执行, 并且使用不同的语句替换 `yield`表达式

```javascript
const g = function*(x, y) {
  let result = yield x + y
  return result
}

const gen = g(1, 2)
gen.next() // Object {value: 3, done: false}

gen.next(1) // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
gen.throw(new Error('出错了')) // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));
gen.return(2) // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
```

- `next()`是将`yield`表达式替换成一个值。
- `throw()`是将`yield`表达式替换成一个`throw`语句。
- `return()`是将`yield`表达式替换成一个`return`语句。

## yield\* 表达式

- ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

  ```javascript
  function* bar() {
    yield 'x'
    yield* foo()
    yield 'y'
  }

  // 等同于
  function* bar() {
    yield 'x'
    yield 'a'
    yield 'b'
    yield 'y'
  }

  // 等同于
  function* bar() {
    yield 'x'
    for (let v of foo()) {
      yield v
    }
    yield 'y'
  }

  for (let v of bar()) {
    console.log(v)
  }
  // "x"
  // "a"
  // "b"
  // "y"
  ```

- 如果`yield`表达式后面跟的是一个遍历器对象，需要在`yield`表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为`yield*`表达式。

- `yield*`后面的 Generator 函数（没有`return`语句时），等同于在 Generator 函数内部，部署一个`for...of`循环。

- 在有`return`语句时，则需要用`var value = yield* iterator`的形式获取`return`语句的值。

- 如果`yield*`后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。

  ```javascript
  function* gen() {
    yield* ['a', 'b', 'c']
  }

  gen().next() // { value:"a", done:false }
  // 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。
  ```

- 实际上，任何数据结构只要有 Iterator 接口，就可以被`yield*`遍历。

## 作为对象属性的 Generator 函数

如果一个对象的属性是 Generator 函数，可以简写成下面的形式。

```javascript
let obj = {
  * myGeneratorMethod() {
    ···
  }
};
```

属性前面有一个星号，表示这个属性是一个 Generator 函数。

## Generator 函数的 this

Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的`prototype`对象上的方法。

```javascript
function* g() {}

g.prototype.hello = function() {
  return 'hi!'
}

let obj = g()

obj instanceof g // true
obj.hello() // 'hi!'
```

上面代码表明，Generator 函数`g`返回的遍历器`obj`，是`g`的实例，而且继承了`g.prototype`。但是，如果把`g`当作普通的构造函数，并不会生效，因为`g`返回的总是遍历器对象，而不是`this`对象

```javascript
function* g() {
  this.a = 11
}

let obj = g()
obj.next()
obj.a // undefined
```

Generator 函数也不能跟`new`命令一起用，会报错。

**变通方法。生成一个空对象，使用`call`方法绑定 Generator 函数内部的`this`。**

```javascript
function* F() {
  this.a = 1
  yield (this.b = 2)
  yield (this.c = 3)
}
var obj = {}
var f = F.call(obj)

f.next() // Object {value: 2, done: false}
f.next() // Object {value: 3, done: false}
f.next() // Object {value: undefined, done: true}

obj.a // 1
obj.b // 2
obj.c // 3
```

# Generator 函数的异步应用

## 传统方法

- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象

## 回调函数

```javascript
fs.readFile('/etc/passwd', 'utf-8', function(err, data) {
  if (err) throw err
  console.log(data)
})
```

一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象`err`（如果没有错误，该参数就是`null`）？

原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。

## Generator 函数----协程

传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。

```javascript
function* asyncJob() {
  // ...其他代码
  var f = yield readFile(fileA)
  // ...其他代码
}
```

上面代码的函数`asyncJob`是一个协程，它的奥妙就在其中的`yield`命令。它表示执行到此处，执行权将交给其他协程。也就是说，`yield`命令是异步两个阶段的分界线。

协程遇到`yield`命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除`yield`命令，简直一模一样。

## Thunk 函数的含义

编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。

```javascript
function f(m) {
  return m * 2
}

f(x + 5)

// 等同于

var thunk = function() {
  return x + 5
}

function f(thunk) {
  return thunk() * 2
}
```

这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。

## Generator 仿长轮询

```javascript
let ajax = function*(params) {
  yield new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ code: 0 })
    }, 200)
  })
}

let pull = function(params) {
  let step = ajax().next()
  step.value.then(res => {
    if (res.code === 0) {
      console.log(res)
    } else {
      setTimeout(() => {
        console.log('wait')
        pull()
      }, 1000)
    }
  })
}
pull()
```

# Async 函数

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

`async`函数就是**将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已**。

`async`函数对 Generator 函数的改进，体现在以下四点。

- 内置执行器。

  Generator 函数的执行必须靠执行器，所以才有了`co`模块，而`async`函数自带执行器。也就是说，`async`函数的执行，与普通函数一模一样，只要一行。

  ```javascript
  asyncReadFile()
  ```

  上面的代码调用了`asyncReadFile`函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用`next`方法，或者用`co`模块，才能真正执行，得到最后结果。

- 更好的语义。
- 更广的适用性。
- 返回值是 Promise。

## 语法

### 返回 Promise 对象

`async`函数返回一个 Promise 对象。

`async`函数内部`return`语句返回的值，会成为`then`方法回调函数的参数

`async`函数内部抛出错误，会导致返回的 Promise 对象变为`reject`状态。抛出的错误对象会被`catch`方法回调函数接收到

### await 并发读取远程 URl

```javascript
async function logInOrder(urls) {
  // 并发读取远程URL
  const textPromises = urls.map(async url => {
    const response = await fetch(url)
    return response.text()
  })

  // 按次序输出
  for (const textPromise of textPromises) {
    console.log(await textPromise)
  }
}
```
